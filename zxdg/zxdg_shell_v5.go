// package zxdg acts as a client for the xdg_shell_unstable_v5 wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: /home/malcolm/git/ulubis/cl-wayland/xdg-shell-unstable-v5.xml
// on 2019-03-24 01:49:10 +0000
package zxdg

import (
	"sync"

	"github.com/dkolbly/wl"
)

type XdgShellDestroyEvent struct {
}

type XdgShellDestroyHandler interface {
	HandleXdgShellDestroy(XdgShellDestroyEvent)
}

func (p *XdgShell) AddDestroyHandler(h XdgShellDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgShell) RemoveDestroyHandler(h XdgShellDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgShellUseUnstableVersionEvent struct {
	Version int32
}

type XdgShellUseUnstableVersionHandler interface {
	HandleXdgShellUseUnstableVersion(XdgShellUseUnstableVersionEvent)
}

func (p *XdgShell) AddUseUnstableVersionHandler(h XdgShellUseUnstableVersionHandler) {
	if h != nil {
		p.mu.Lock()
		p.useUnstableVersionHandlers = append(p.useUnstableVersionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgShell) RemoveUseUnstableVersionHandler(h XdgShellUseUnstableVersionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.useUnstableVersionHandlers {
		if e == h {
			p.useUnstableVersionHandlers = append(p.useUnstableVersionHandlers[:i], p.useUnstableVersionHandlers[i+1:]...)
			break
		}
	}
}

type XdgShellGetXdgSurfaceEvent struct {
	Id      *XdgSurface
	Surface *wl.Surface
}

type XdgShellGetXdgSurfaceHandler interface {
	HandleXdgShellGetXdgSurface(XdgShellGetXdgSurfaceEvent)
}

func (p *XdgShell) AddGetXdgSurfaceHandler(h XdgShellGetXdgSurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgShell) RemoveGetXdgSurfaceHandler(h XdgShellGetXdgSurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getXdgSurfaceHandlers {
		if e == h {
			p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers[:i], p.getXdgSurfaceHandlers[i+1:]...)
			break
		}
	}
}

type XdgShellGetXdgPopupEvent struct {
	Id      *XdgPopup
	Surface *wl.Surface
	Parent  *wl.Surface
	Seat    *wl.Seat
	Serial  uint32
	X       int32
	Y       int32
}

type XdgShellGetXdgPopupHandler interface {
	HandleXdgShellGetXdgPopup(XdgShellGetXdgPopupEvent)
}

func (p *XdgShell) AddGetXdgPopupHandler(h XdgShellGetXdgPopupHandler) {
	if h != nil {
		p.mu.Lock()
		p.getXdgPopupHandlers = append(p.getXdgPopupHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgShell) RemoveGetXdgPopupHandler(h XdgShellGetXdgPopupHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getXdgPopupHandlers {
		if e == h {
			p.getXdgPopupHandlers = append(p.getXdgPopupHandlers[:i], p.getXdgPopupHandlers[i+1:]...)
			break
		}
	}
}

type XdgShellPongEvent struct {
	Serial uint32
}

type XdgShellPongHandler interface {
	HandleXdgShellPong(XdgShellPongEvent)
}

func (p *XdgShell) AddPongHandler(h XdgShellPongHandler) {
	if h != nil {
		p.mu.Lock()
		p.pongHandlers = append(p.pongHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgShell) RemovePongHandler(h XdgShellPongHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.pongHandlers {
		if e == h {
			p.pongHandlers = append(p.pongHandlers[:i], p.pongHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgShell) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgShellDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgShellDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.useUnstableVersionHandlers) > 0 {
			ev := XdgShellUseUnstableVersionEvent{}
			ev.Version = event.Int32()
			p.mu.RLock()
			for _, h := range p.useUnstableVersionHandlers {
				h.HandleXdgShellUseUnstableVersion(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getXdgSurfaceHandlers) > 0 {
			ev := XdgShellGetXdgSurfaceEvent{}
			ev.Id = NewXdgSurface(p.Context())
			ev.Surface = event.Proxy(p.Context()).(*wl.Surface)
			p.mu.RLock()
			for _, h := range p.getXdgSurfaceHandlers {
				h.HandleXdgShellGetXdgSurface(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.getXdgPopupHandlers) > 0 {
			ev := XdgShellGetXdgPopupEvent{}
			ev.Id = NewXdgPopup(p.Context())
			ev.Surface = event.Proxy(p.Context()).(*wl.Surface)
			ev.Parent = event.Proxy(p.Context()).(*wl.Surface)
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.getXdgPopupHandlers {
				h.HandleXdgShellGetXdgPopup(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.pongHandlers) > 0 {
			ev := XdgShellPongEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.pongHandlers {
				h.HandleXdgShellPong(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgShell struct {
	wl.BaseProxy
	mu                         sync.RWMutex
	destroyHandlers            []XdgShellDestroyHandler
	useUnstableVersionHandlers []XdgShellUseUnstableVersionHandler
	getXdgSurfaceHandlers      []XdgShellGetXdgSurfaceHandler
	getXdgPopupHandlers        []XdgShellGetXdgPopupHandler
	pongHandlers               []XdgShellPongHandler
}

func NewXdgShell(ctx *wl.Context) *XdgShell {
	ret := new(XdgShell)
	ctx.Register(ret)
	return ret
}

// Ping will check if the client is alive.
//
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_shell object it created.
//
func (p *XdgShell) Ping(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

const (
	XdgShellVersionCurrent = 5
)

const (
	XdgShellErrorRole               = 0
	XdgShellErrorDefunctSurfaces    = 1
	XdgShellErrorNotTheTopmostPopup = 2
	XdgShellErrorInvalidPopupParent = 3
)

type XdgSurfaceDestroyEvent struct {
}

type XdgSurfaceDestroyHandler interface {
	HandleXdgSurfaceDestroy(XdgSurfaceDestroyEvent)
}

func (p *XdgSurface) AddDestroyHandler(h XdgSurfaceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveDestroyHandler(h XdgSurfaceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetParentEvent struct {
	Parent *XdgSurface
}

type XdgSurfaceSetParentHandler interface {
	HandleXdgSurfaceSetParent(XdgSurfaceSetParentEvent)
}

func (p *XdgSurface) AddSetParentHandler(h XdgSurfaceSetParentHandler) {
	if h != nil {
		p.mu.Lock()
		p.setParentHandlers = append(p.setParentHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetParentHandler(h XdgSurfaceSetParentHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setParentHandlers {
		if e == h {
			p.setParentHandlers = append(p.setParentHandlers[:i], p.setParentHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetTitleEvent struct {
	Title string
}

type XdgSurfaceSetTitleHandler interface {
	HandleXdgSurfaceSetTitle(XdgSurfaceSetTitleEvent)
}

func (p *XdgSurface) AddSetTitleHandler(h XdgSurfaceSetTitleHandler) {
	if h != nil {
		p.mu.Lock()
		p.setTitleHandlers = append(p.setTitleHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetTitleHandler(h XdgSurfaceSetTitleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setTitleHandlers {
		if e == h {
			p.setTitleHandlers = append(p.setTitleHandlers[:i], p.setTitleHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetAppIdEvent struct {
	AppId string
}

type XdgSurfaceSetAppIdHandler interface {
	HandleXdgSurfaceSetAppId(XdgSurfaceSetAppIdEvent)
}

func (p *XdgSurface) AddSetAppIdHandler(h XdgSurfaceSetAppIdHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAppIdHandlers = append(p.setAppIdHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetAppIdHandler(h XdgSurfaceSetAppIdHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAppIdHandlers {
		if e == h {
			p.setAppIdHandlers = append(p.setAppIdHandlers[:i], p.setAppIdHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceShowWindowMenuEvent struct {
	Seat   *wl.Seat
	Serial uint32
	X      int32
	Y      int32
}

type XdgSurfaceShowWindowMenuHandler interface {
	HandleXdgSurfaceShowWindowMenu(XdgSurfaceShowWindowMenuEvent)
}

func (p *XdgSurface) AddShowWindowMenuHandler(h XdgSurfaceShowWindowMenuHandler) {
	if h != nil {
		p.mu.Lock()
		p.showWindowMenuHandlers = append(p.showWindowMenuHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveShowWindowMenuHandler(h XdgSurfaceShowWindowMenuHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.showWindowMenuHandlers {
		if e == h {
			p.showWindowMenuHandlers = append(p.showWindowMenuHandlers[:i], p.showWindowMenuHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceMoveEvent struct {
	Seat   *wl.Seat
	Serial uint32
}

type XdgSurfaceMoveHandler interface {
	HandleXdgSurfaceMove(XdgSurfaceMoveEvent)
}

func (p *XdgSurface) AddMoveHandler(h XdgSurfaceMoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.moveHandlers = append(p.moveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveMoveHandler(h XdgSurfaceMoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.moveHandlers {
		if e == h {
			p.moveHandlers = append(p.moveHandlers[:i], p.moveHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceResizeEvent struct {
	Seat   *wl.Seat
	Serial uint32
	Edges  uint32
}

type XdgSurfaceResizeHandler interface {
	HandleXdgSurfaceResize(XdgSurfaceResizeEvent)
}

func (p *XdgSurface) AddResizeHandler(h XdgSurfaceResizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.resizeHandlers = append(p.resizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveResizeHandler(h XdgSurfaceResizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resizeHandlers {
		if e == h {
			p.resizeHandlers = append(p.resizeHandlers[:i], p.resizeHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceAckConfigureEvent struct {
	Serial uint32
}

type XdgSurfaceAckConfigureHandler interface {
	HandleXdgSurfaceAckConfigure(XdgSurfaceAckConfigureEvent)
}

func (p *XdgSurface) AddAckConfigureHandler(h XdgSurfaceAckConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.ackConfigureHandlers = append(p.ackConfigureHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveAckConfigureHandler(h XdgSurfaceAckConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.ackConfigureHandlers {
		if e == h {
			p.ackConfigureHandlers = append(p.ackConfigureHandlers[:i], p.ackConfigureHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetWindowGeometryEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type XdgSurfaceSetWindowGeometryHandler interface {
	HandleXdgSurfaceSetWindowGeometry(XdgSurfaceSetWindowGeometryEvent)
}

func (p *XdgSurface) AddSetWindowGeometryHandler(h XdgSurfaceSetWindowGeometryHandler) {
	if h != nil {
		p.mu.Lock()
		p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetWindowGeometryHandler(h XdgSurfaceSetWindowGeometryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setWindowGeometryHandlers {
		if e == h {
			p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers[:i], p.setWindowGeometryHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetMaximizedEvent struct {
}

type XdgSurfaceSetMaximizedHandler interface {
	HandleXdgSurfaceSetMaximized(XdgSurfaceSetMaximizedEvent)
}

func (p *XdgSurface) AddSetMaximizedHandler(h XdgSurfaceSetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaximizedHandlers = append(p.setMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetMaximizedHandler(h XdgSurfaceSetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaximizedHandlers {
		if e == h {
			p.setMaximizedHandlers = append(p.setMaximizedHandlers[:i], p.setMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceUnsetMaximizedEvent struct {
}

type XdgSurfaceUnsetMaximizedHandler interface {
	HandleXdgSurfaceUnsetMaximized(XdgSurfaceUnsetMaximizedEvent)
}

func (p *XdgSurface) AddUnsetMaximizedHandler(h XdgSurfaceUnsetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveUnsetMaximizedHandler(h XdgSurfaceUnsetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetMaximizedHandlers {
		if e == h {
			p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers[:i], p.unsetMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetFullscreenEvent struct {
	Output *wl.Output
}

type XdgSurfaceSetFullscreenHandler interface {
	HandleXdgSurfaceSetFullscreen(XdgSurfaceSetFullscreenEvent)
}

func (p *XdgSurface) AddSetFullscreenHandler(h XdgSurfaceSetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.setFullscreenHandlers = append(p.setFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetFullscreenHandler(h XdgSurfaceSetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setFullscreenHandlers {
		if e == h {
			p.setFullscreenHandlers = append(p.setFullscreenHandlers[:i], p.setFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceUnsetFullscreenEvent struct {
}

type XdgSurfaceUnsetFullscreenHandler interface {
	HandleXdgSurfaceUnsetFullscreen(XdgSurfaceUnsetFullscreenEvent)
}

func (p *XdgSurface) AddUnsetFullscreenHandler(h XdgSurfaceUnsetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveUnsetFullscreenHandler(h XdgSurfaceUnsetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetFullscreenHandlers {
		if e == h {
			p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers[:i], p.unsetFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetMinimizedEvent struct {
}

type XdgSurfaceSetMinimizedHandler interface {
	HandleXdgSurfaceSetMinimized(XdgSurfaceSetMinimizedEvent)
}

func (p *XdgSurface) AddSetMinimizedHandler(h XdgSurfaceSetMinimizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMinimizedHandlers = append(p.setMinimizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetMinimizedHandler(h XdgSurfaceSetMinimizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMinimizedHandlers {
		if e == h {
			p.setMinimizedHandlers = append(p.setMinimizedHandlers[:i], p.setMinimizedHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgSurface) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgSurfaceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgSurfaceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setParentHandlers) > 0 {
			ev := XdgSurfaceSetParentEvent{}
			ev.Parent = event.Proxy(p.Context()).(*XdgSurface)
			p.mu.RLock()
			for _, h := range p.setParentHandlers {
				h.HandleXdgSurfaceSetParent(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setTitleHandlers) > 0 {
			ev := XdgSurfaceSetTitleEvent{}
			ev.Title = event.String()
			p.mu.RLock()
			for _, h := range p.setTitleHandlers {
				h.HandleXdgSurfaceSetTitle(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setAppIdHandlers) > 0 {
			ev := XdgSurfaceSetAppIdEvent{}
			ev.AppId = event.String()
			p.mu.RLock()
			for _, h := range p.setAppIdHandlers {
				h.HandleXdgSurfaceSetAppId(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.showWindowMenuHandlers) > 0 {
			ev := XdgSurfaceShowWindowMenuEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.showWindowMenuHandlers {
				h.HandleXdgSurfaceShowWindowMenu(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.moveHandlers) > 0 {
			ev := XdgSurfaceMoveEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.moveHandlers {
				h.HandleXdgSurfaceMove(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.resizeHandlers) > 0 {
			ev := XdgSurfaceResizeEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.Edges = event.Uint32()
			p.mu.RLock()
			for _, h := range p.resizeHandlers {
				h.HandleXdgSurfaceResize(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.ackConfigureHandlers) > 0 {
			ev := XdgSurfaceAckConfigureEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.ackConfigureHandlers {
				h.HandleXdgSurfaceAckConfigure(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.setWindowGeometryHandlers) > 0 {
			ev := XdgSurfaceSetWindowGeometryEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setWindowGeometryHandlers {
				h.HandleXdgSurfaceSetWindowGeometry(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.setMaximizedHandlers) > 0 {
			ev := XdgSurfaceSetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMaximizedHandlers {
				h.HandleXdgSurfaceSetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 10:
		if len(p.unsetMaximizedHandlers) > 0 {
			ev := XdgSurfaceUnsetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.unsetMaximizedHandlers {
				h.HandleXdgSurfaceUnsetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 11:
		if len(p.setFullscreenHandlers) > 0 {
			ev := XdgSurfaceSetFullscreenEvent{}
			ev.Output = event.Proxy(p.Context()).(*wl.Output)
			p.mu.RLock()
			for _, h := range p.setFullscreenHandlers {
				h.HandleXdgSurfaceSetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 12:
		if len(p.unsetFullscreenHandlers) > 0 {
			ev := XdgSurfaceUnsetFullscreenEvent{}
			p.mu.RLock()
			for _, h := range p.unsetFullscreenHandlers {
				h.HandleXdgSurfaceUnsetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 13:
		if len(p.setMinimizedHandlers) > 0 {
			ev := XdgSurfaceSetMinimizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMinimizedHandlers {
				h.HandleXdgSurfaceSetMinimized(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgSurface struct {
	wl.BaseProxy
	mu                        sync.RWMutex
	destroyHandlers           []XdgSurfaceDestroyHandler
	setParentHandlers         []XdgSurfaceSetParentHandler
	setTitleHandlers          []XdgSurfaceSetTitleHandler
	setAppIdHandlers          []XdgSurfaceSetAppIdHandler
	showWindowMenuHandlers    []XdgSurfaceShowWindowMenuHandler
	moveHandlers              []XdgSurfaceMoveHandler
	resizeHandlers            []XdgSurfaceResizeHandler
	ackConfigureHandlers      []XdgSurfaceAckConfigureHandler
	setWindowGeometryHandlers []XdgSurfaceSetWindowGeometryHandler
	setMaximizedHandlers      []XdgSurfaceSetMaximizedHandler
	unsetMaximizedHandlers    []XdgSurfaceUnsetMaximizedHandler
	setFullscreenHandlers     []XdgSurfaceSetFullscreenHandler
	unsetFullscreenHandlers   []XdgSurfaceUnsetFullscreenHandler
	setMinimizedHandlers      []XdgSurfaceSetMinimizedHandler
}

func NewXdgSurface(ctx *wl.Context) *XdgSurface {
	ret := new(XdgSurface)
	ctx.Register(ret)
	return ret
}

// Configure will suggest a surface change.
//
//
// The configure event asks the client to resize its surface or to
// change its state.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor need to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients should arrange their surface for the new size and
// states, and then send a ack_configure request with the serial
// sent in this configure event at some point before committing
// the new surface.
//
// If the client receives multiple configure events before it
// can respond to one, it is free to discard all but the last
// event it received.
//
func (p *XdgSurface) Configure(width int32, height int32, states []int32, serial uint32) error {
	return p.Context().SendRequest(p, 0, width, height, states, serial)
}

// Close will surface wants to be closed.
//
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any...
//
// This is only a request that the user intends to close your
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data...
//
func (p *XdgSurface) Close() error {
	return p.Context().SendRequest(p, 1)
}

const (
	XdgSurfaceResizeEdgeNone        = 0
	XdgSurfaceResizeEdgeTop         = 1
	XdgSurfaceResizeEdgeBottom      = 2
	XdgSurfaceResizeEdgeLeft        = 4
	XdgSurfaceResizeEdgeTopLeft     = 5
	XdgSurfaceResizeEdgeBottomLeft  = 6
	XdgSurfaceResizeEdgeRight       = 8
	XdgSurfaceResizeEdgeTopRight    = 9
	XdgSurfaceResizeEdgeBottomRight = 10
)

const (
	XdgSurfaceStateMaximized  = 1
	XdgSurfaceStateFullscreen = 2
	XdgSurfaceStateResizing   = 3
	XdgSurfaceStateActivated  = 4
)

type XdgPopupDestroyEvent struct {
}

type XdgPopupDestroyHandler interface {
	HandleXdgPopupDestroy(XdgPopupDestroyEvent)
}

func (p *XdgPopup) AddDestroyHandler(h XdgPopupDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPopup) RemoveDestroyHandler(h XdgPopupDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgPopup) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgPopupDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgPopupDestroy(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgPopup struct {
	wl.BaseProxy
	mu              sync.RWMutex
	destroyHandlers []XdgPopupDestroyHandler
}

func NewXdgPopup(ctx *wl.Context) *XdgPopup {
	ret := new(XdgPopup)
	ctx.Register(ret)
	return ret
}

// PopupDone will popup interaction is done.
//
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
//
func (p *XdgPopup) PopupDone() error {
	return p.Context().SendRequest(p, 0)
}
