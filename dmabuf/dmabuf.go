// package Dmabuf acts as a client for the linux_dmabuf_unstable_v1 wayland protocol.

// generated by wl-scanner
// https://github.com/malcolmstill/wl-scanner
// from: /usr/share/wayland-protocols/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml
// on 2020-04-17 01:02:10 +0100
package dmabuf

import (
	"sync"

	"github.com/malcolmstill/wl"
)

type ZwpLinuxDmabufV1DestroyEvent struct {
}

type ZwpLinuxDmabufV1DestroyHandler interface {
	HandleZwpLinuxDmabufV1Destroy(ZwpLinuxDmabufV1DestroyEvent)
}

func (p *ZwpLinuxDmabufV1) AddDestroyHandler(h ZwpLinuxDmabufV1DestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxDmabufV1) RemoveDestroyHandler(h ZwpLinuxDmabufV1DestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxDmabufV1CreateParamsEvent struct {
	ParamsId *ZwpLinuxBufferParamsV1
}

type ZwpLinuxDmabufV1CreateParamsHandler interface {
	HandleZwpLinuxDmabufV1CreateParams(ZwpLinuxDmabufV1CreateParamsEvent)
}

func (p *ZwpLinuxDmabufV1) AddCreateParamsHandler(h ZwpLinuxDmabufV1CreateParamsHandler) {
	if h != nil {
		p.mu.Lock()
		p.createParamsHandlers = append(p.createParamsHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxDmabufV1) RemoveCreateParamsHandler(h ZwpLinuxDmabufV1CreateParamsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createParamsHandlers {
		if e == h {
			p.createParamsHandlers = append(p.createParamsHandlers[:i], p.createParamsHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpLinuxDmabufV1) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := ZwpLinuxDmabufV1DestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleZwpLinuxDmabufV1Destroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.createParamsHandlers) > 0 {
			ev := ZwpLinuxDmabufV1CreateParamsEvent{}
			ev.ParamsId = NewZwpLinuxBufferParamsV1(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createParamsHandlers {
				h.HandleZwpLinuxDmabufV1CreateParams(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ZwpLinuxDmabufV1 struct {
	wl.BaseProxy
	mu                   sync.RWMutex
	destroyHandlers      []ZwpLinuxDmabufV1DestroyHandler
	createParamsHandlers []ZwpLinuxDmabufV1CreateParamsHandler
}

func NewZwpLinuxDmabufV1(ctx *wl.Context, id int) *ZwpLinuxDmabufV1 {
	ret := new(ZwpLinuxDmabufV1)
	ctx.RegisterId(ret, id)
	return ret
}

// Format will supported buffer format.
//
//
// This event advertises one buffer format that the server supports.
// All the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees
// that the client has received all supported formats.
//
// For the definition of the format codes, see the
// zwp_linux_buffer_params_v1::create request.
//
// Warning: the 'format' event is likely to be deprecated and replaced
// with the 'modifier' event introduced in zwp_linux_dmabuf_v1
// version 3, described below. Please refrain from using the information
// received from this event.
//
func (p *ZwpLinuxDmabufV1) Format(format uint32) error {
	return p.Context().SendRequest(p, 0, format)
}

// Modifier will supported buffer format modifier.
//
//
// This event advertises the formats that the server supports, along with
// the modifiers supported for each format. All the supported modifiers
// for all the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees that
// the client has received all supported format-modifier pairs.
//
// For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
// 0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
// It indicates that the server can support the format with an implicit
// modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
// is as if no explicit modifier is specified. The effective modifier
// will be derived from the dmabuf.
//
// For the definition of the format and modifier codes, see the
// zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
// requests.
//
func (p *ZwpLinuxDmabufV1) Modifier(format uint32, modifier_hi uint32, modifier_lo uint32) error {
	return p.Context().SendRequest(p, 1, format, modifier_hi, modifier_lo)
}

type ZwpLinuxBufferParamsV1DestroyEvent struct {
}

type ZwpLinuxBufferParamsV1DestroyHandler interface {
	HandleZwpLinuxBufferParamsV1Destroy(ZwpLinuxBufferParamsV1DestroyEvent)
}

func (p *ZwpLinuxBufferParamsV1) AddDestroyHandler(h ZwpLinuxBufferParamsV1DestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxBufferParamsV1) RemoveDestroyHandler(h ZwpLinuxBufferParamsV1DestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxBufferParamsV1AddEvent struct {
	Fd         uintptr
	PlaneIdx   uint32
	Offset     uint32
	Stride     uint32
	ModifierHi uint32
	ModifierLo uint32
}

type ZwpLinuxBufferParamsV1AddHandler interface {
	HandleZwpLinuxBufferParamsV1Add(ZwpLinuxBufferParamsV1AddEvent)
}

func (p *ZwpLinuxBufferParamsV1) AddAddHandler(h ZwpLinuxBufferParamsV1AddHandler) {
	if h != nil {
		p.mu.Lock()
		p.addHandlers = append(p.addHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxBufferParamsV1) RemoveAddHandler(h ZwpLinuxBufferParamsV1AddHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.addHandlers {
		if e == h {
			p.addHandlers = append(p.addHandlers[:i], p.addHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxBufferParamsV1CreateEvent struct {
	Width  int32
	Height int32
	Format uint32
	Flags  uint32
}

type ZwpLinuxBufferParamsV1CreateHandler interface {
	HandleZwpLinuxBufferParamsV1Create(ZwpLinuxBufferParamsV1CreateEvent)
}

func (p *ZwpLinuxBufferParamsV1) AddCreateHandler(h ZwpLinuxBufferParamsV1CreateHandler) {
	if h != nil {
		p.mu.Lock()
		p.createHandlers = append(p.createHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxBufferParamsV1) RemoveCreateHandler(h ZwpLinuxBufferParamsV1CreateHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createHandlers {
		if e == h {
			p.createHandlers = append(p.createHandlers[:i], p.createHandlers[i+1:]...)
			break
		}
	}
}

type ZwpLinuxBufferParamsV1CreateImmedEvent struct {
	BufferId *wl.Buffer
	Width    int32
	Height   int32
	Format   uint32
	Flags    uint32
}

type ZwpLinuxBufferParamsV1CreateImmedHandler interface {
	HandleZwpLinuxBufferParamsV1CreateImmed(ZwpLinuxBufferParamsV1CreateImmedEvent)
}

func (p *ZwpLinuxBufferParamsV1) AddCreateImmedHandler(h ZwpLinuxBufferParamsV1CreateImmedHandler) {
	if h != nil {
		p.mu.Lock()
		p.createImmedHandlers = append(p.createImmedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ZwpLinuxBufferParamsV1) RemoveCreateImmedHandler(h ZwpLinuxBufferParamsV1CreateImmedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createImmedHandlers {
		if e == h {
			p.createImmedHandlers = append(p.createImmedHandlers[:i], p.createImmedHandlers[i+1:]...)
			break
		}
	}
}

func (p *ZwpLinuxBufferParamsV1) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := ZwpLinuxBufferParamsV1DestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleZwpLinuxBufferParamsV1Destroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.addHandlers) > 0 {
			ev := ZwpLinuxBufferParamsV1AddEvent{}
			ev.Fd = p.Context().NextFD()
			ev.PlaneIdx = event.Uint32()
			ev.Offset = event.Uint32()
			ev.Stride = event.Uint32()
			ev.ModifierHi = event.Uint32()
			ev.ModifierLo = event.Uint32()
			p.mu.RLock()
			for _, h := range p.addHandlers {
				h.HandleZwpLinuxBufferParamsV1Add(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.createHandlers) > 0 {
			ev := ZwpLinuxBufferParamsV1CreateEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.Format = event.Uint32()
			ev.Flags = event.Uint32()
			p.mu.RLock()
			for _, h := range p.createHandlers {
				h.HandleZwpLinuxBufferParamsV1Create(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.createImmedHandlers) > 0 {
			ev := ZwpLinuxBufferParamsV1CreateImmedEvent{}
			ev.BufferId = wl.NewBuffer(p.Context(), int(event.Uint32()))
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.Format = event.Uint32()
			ev.Flags = event.Uint32()
			p.mu.RLock()
			for _, h := range p.createImmedHandlers {
				h.HandleZwpLinuxBufferParamsV1CreateImmed(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ZwpLinuxBufferParamsV1 struct {
	wl.BaseProxy
	mu                  sync.RWMutex
	destroyHandlers     []ZwpLinuxBufferParamsV1DestroyHandler
	addHandlers         []ZwpLinuxBufferParamsV1AddHandler
	createHandlers      []ZwpLinuxBufferParamsV1CreateHandler
	createImmedHandlers []ZwpLinuxBufferParamsV1CreateImmedHandler
}

func NewZwpLinuxBufferParamsV1(ctx *wl.Context, id int) *ZwpLinuxBufferParamsV1 {
	ret := new(ZwpLinuxBufferParamsV1)
	ctx.RegisterId(ret, id)
	return ret
}

// Created will buffer creation succeeded.
//
//
// This event indicates that the attempted buffer creation was
// successful. It provides the new wl_buffer referencing the dmabuf(s).
//
// Upon receiving this event, the client should destroy the
// zlinux_dmabuf_params object.
//
func (p *ZwpLinuxBufferParamsV1) Created(id int) (*wl.Buffer, error) {
	ret := wl.NewBuffer(p.Context(), id)
	return ret, p.Context().SendRequest(p, 0, wl.Proxy(ret))
}

// Failed will buffer creation failed.
//
//
// This event indicates that the attempted buffer creation has
// failed. It usually means that one of the dmabuf constraints
// has not been fulfilled.
//
// Upon receiving this event, the client should destroy the
// zlinux_buffer_params object.
//
func (p *ZwpLinuxBufferParamsV1) Failed() error {
	return p.Context().SendRequest(p, 1)
}

const (
	ZwpLinuxBufferParamsV1ErrorAlreadyUsed       = 0
	ZwpLinuxBufferParamsV1ErrorPlaneIdx          = 1
	ZwpLinuxBufferParamsV1ErrorPlaneSet          = 2
	ZwpLinuxBufferParamsV1ErrorIncomplete        = 3
	ZwpLinuxBufferParamsV1ErrorInvalidFormat     = 4
	ZwpLinuxBufferParamsV1ErrorInvalidDimensions = 5
	ZwpLinuxBufferParamsV1ErrorOutOfBounds       = 6
	ZwpLinuxBufferParamsV1ErrorInvalidWlBuffer   = 7
)

const (
	ZwpLinuxBufferParamsV1FlagsYInvert     = 1
	ZwpLinuxBufferParamsV1FlagsInterlaced  = 2
	ZwpLinuxBufferParamsV1FlagsBottomFirst = 4
)
