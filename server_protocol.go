// package wl acts as a client for the wayland wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: https://cgit.freedesktop.org/wayland/wayland/plain/protocol/wayland.xml
// on 2019-04-14 01:35:54 +0100
package wl

import (
	"sync"
)

type DisplaySyncEvent struct {
	Callback *Callback
}

type DisplaySyncHandler interface {
	HandleDisplaySync(DisplaySyncEvent)
}

func (p *Display) AddSyncHandler(h DisplaySyncHandler) {
	if h != nil {
		p.mu.Lock()
		p.syncHandlers = append(p.syncHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Display) RemoveSyncHandler(h DisplaySyncHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.syncHandlers {
		if e == h {
			p.syncHandlers = append(p.syncHandlers[:i], p.syncHandlers[i+1:]...)
			break
		}
	}
}

type DisplayGetRegistryEvent struct {
	Registry *Registry
}

type DisplayGetRegistryHandler interface {
	HandleDisplayGetRegistry(DisplayGetRegistryEvent)
}

func (p *Display) AddGetRegistryHandler(h DisplayGetRegistryHandler) {
	if h != nil {
		p.mu.Lock()
		p.getRegistryHandlers = append(p.getRegistryHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Display) RemoveGetRegistryHandler(h DisplayGetRegistryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getRegistryHandlers {
		if e == h {
			p.getRegistryHandlers = append(p.getRegistryHandlers[:i], p.getRegistryHandlers[i+1:]...)
			break
		}
	}
}

func (p *Display) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.syncHandlers) > 0 {
			ev := DisplaySyncEvent{}
			ev.Callback = NewCallback(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.syncHandlers {
				h.HandleDisplaySync(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getRegistryHandlers) > 0 {
			ev := DisplayGetRegistryEvent{}
			ev.Registry = NewRegistry(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getRegistryHandlers {
				h.HandleDisplayGetRegistry(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Display struct {
	BaseProxy
	mu                  sync.RWMutex
	syncHandlers        []DisplaySyncHandler
	getRegistryHandlers []DisplayGetRegistryHandler
}

func NewDisplay(ctx *Context, id int) *Display {
	ret := new(Display)
	ctx.RegisterId(ret, id)
	return ret
}

// Error will fatal error event.
//
//
// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
//
func (p *Display) Error(object_id, code uint32, message string) error {
	return p.Context().SendRequest(p, 0, object_id, code, message)
}

// DeleteId will acknowledge object ID deletion.
//
//
// This event is used internally by the object ID management
// logic.  When a client deletes an object, the server will send
// this event to acknowledge that it has seen the delete request.
// When the client receives this event, it will know that it can
// safely reuse the object ID.
//
func (p *Display) DeleteId(id uint32) error {
	return p.Context().SendRequest(p, 1, id)
}

const (
	DisplayErrorInvalidObject  = 0
	DisplayErrorInvalidMethod  = 1
	DisplayErrorNoMemory       = 2
	DisplayErrorImplementation = 3
)

type RegistryBindEvent struct {
	Name    uint32
	Id      uint32 //Proxy
	Iface   string
	Version uint32
}

type RegistryBindHandler interface {
	HandleRegistryBind(RegistryBindEvent)
}

func (p *Registry) AddBindHandler(h RegistryBindHandler) {
	if h != nil {
		p.mu.Lock()
		p.bindHandlers = append(p.bindHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Registry) RemoveBindHandler(h RegistryBindHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.bindHandlers {
		if e == h {
			p.bindHandlers = append(p.bindHandlers[:i], p.bindHandlers[i+1:]...)
			break
		}
	}
}

func (p *Registry) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.bindHandlers) > 0 {
			ev := RegistryBindEvent{}
			ev.Name = event.Uint32()
			ev.Iface = event.String()
			ev.Version = event.Uint32()
			ev.Id = event.Uint32() //event.Proxy(p.Context())
			p.mu.RLock()
			for _, h := range p.bindHandlers {
				h.HandleRegistryBind(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Registry struct {
	BaseProxy
	mu           sync.RWMutex
	bindHandlers []RegistryBindHandler
}

func NewRegistry(ctx *Context, id int) *Registry {
	ret := new(Registry)
	ctx.RegisterId(ret, id)
	return ret
}

// Global will announce global object.
//
//
// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
//
func (p *Registry) Global(name uint32, iface string, version uint32) error {
	return p.Context().SendRequest(p, 0, name, iface, version)
}

// GlobalRemove will announce removal of global object.
//
//
// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
//
func (p *Registry) GlobalRemove(name uint32) error {
	return p.Context().SendRequest(p, 1, name)
}

type Callback struct {
	BaseProxy
}

func NewCallback(ctx *Context, id int) *Callback {
	ret := new(Callback)
	ctx.RegisterId(ret, id)
	return ret
}

// Done will done event.
//
//
// Notify the client when the related request is done.
//
func (p *Callback) Done(callback_data uint32) error {
	return p.Context().SendRequest(p, 0, callback_data)
}

type CompositorCreateSurfaceEvent struct {
	Id *Surface
}

type CompositorCreateSurfaceHandler interface {
	HandleCompositorCreateSurface(CompositorCreateSurfaceEvent)
}

func (p *Compositor) AddCreateSurfaceHandler(h CompositorCreateSurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.createSurfaceHandlers = append(p.createSurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Compositor) RemoveCreateSurfaceHandler(h CompositorCreateSurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createSurfaceHandlers {
		if e == h {
			p.createSurfaceHandlers = append(p.createSurfaceHandlers[:i], p.createSurfaceHandlers[i+1:]...)
			break
		}
	}
}

type CompositorCreateRegionEvent struct {
	Id *Region
}

type CompositorCreateRegionHandler interface {
	HandleCompositorCreateRegion(CompositorCreateRegionEvent)
}

func (p *Compositor) AddCreateRegionHandler(h CompositorCreateRegionHandler) {
	if h != nil {
		p.mu.Lock()
		p.createRegionHandlers = append(p.createRegionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Compositor) RemoveCreateRegionHandler(h CompositorCreateRegionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createRegionHandlers {
		if e == h {
			p.createRegionHandlers = append(p.createRegionHandlers[:i], p.createRegionHandlers[i+1:]...)
			break
		}
	}
}

func (p *Compositor) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.createSurfaceHandlers) > 0 {
			ev := CompositorCreateSurfaceEvent{}
			ev.Id = NewSurface(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createSurfaceHandlers {
				h.HandleCompositorCreateSurface(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.createRegionHandlers) > 0 {
			ev := CompositorCreateRegionEvent{}
			ev.Id = NewRegion(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createRegionHandlers {
				h.HandleCompositorCreateRegion(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Compositor struct {
	BaseProxy
	mu                    sync.RWMutex
	createSurfaceHandlers []CompositorCreateSurfaceHandler
	createRegionHandlers  []CompositorCreateRegionHandler
}

func NewCompositor(ctx *Context, id int) *Compositor {
	ret := new(Compositor)
	ctx.RegisterId(ret, id)
	return ret
}

type ShmPoolCreateBufferEvent struct {
	Id     *Buffer
	Offset int32
	Width  int32
	Height int32
	Stride int32
	Format uint32
}

type ShmPoolCreateBufferHandler interface {
	HandleShmPoolCreateBuffer(ShmPoolCreateBufferEvent)
}

func (p *ShmPool) AddCreateBufferHandler(h ShmPoolCreateBufferHandler) {
	if h != nil {
		p.mu.Lock()
		p.createBufferHandlers = append(p.createBufferHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShmPool) RemoveCreateBufferHandler(h ShmPoolCreateBufferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createBufferHandlers {
		if e == h {
			p.createBufferHandlers = append(p.createBufferHandlers[:i], p.createBufferHandlers[i+1:]...)
			break
		}
	}
}

type ShmPoolDestroyEvent struct {
}

type ShmPoolDestroyHandler interface {
	HandleShmPoolDestroy(ShmPoolDestroyEvent)
}

func (p *ShmPool) AddDestroyHandler(h ShmPoolDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShmPool) RemoveDestroyHandler(h ShmPoolDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type ShmPoolResizeEvent struct {
	Size int32
}

type ShmPoolResizeHandler interface {
	HandleShmPoolResize(ShmPoolResizeEvent)
}

func (p *ShmPool) AddResizeHandler(h ShmPoolResizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.resizeHandlers = append(p.resizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShmPool) RemoveResizeHandler(h ShmPoolResizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resizeHandlers {
		if e == h {
			p.resizeHandlers = append(p.resizeHandlers[:i], p.resizeHandlers[i+1:]...)
			break
		}
	}
}

func (p *ShmPool) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.createBufferHandlers) > 0 {
			ev := ShmPoolCreateBufferEvent{}
			ev.Id = NewBuffer(p.Context(), int(event.Uint32()))
			ev.Offset = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			ev.Stride = event.Int32()
			ev.Format = event.Uint32()
			p.mu.RLock()
			for _, h := range p.createBufferHandlers {
				h.HandleShmPoolCreateBuffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.destroyHandlers) > 0 {
			ev := ShmPoolDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleShmPoolDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.resizeHandlers) > 0 {
			ev := ShmPoolResizeEvent{}
			ev.Size = event.Int32()
			p.mu.RLock()
			for _, h := range p.resizeHandlers {
				h.HandleShmPoolResize(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ShmPool struct {
	BaseProxy
	mu                   sync.RWMutex
	createBufferHandlers []ShmPoolCreateBufferHandler
	destroyHandlers      []ShmPoolDestroyHandler
	resizeHandlers       []ShmPoolResizeHandler
}

func NewShmPool(ctx *Context, id int) *ShmPool {
	ret := new(ShmPool)
	ctx.RegisterId(ret, id)
	return ret
}

type ShmCreatePoolEvent struct {
	Id   *ShmPool
	Fd   uintptr
	Size int32
}

type ShmCreatePoolHandler interface {
	HandleShmCreatePool(ShmCreatePoolEvent)
}

func (p *Shm) AddCreatePoolHandler(h ShmCreatePoolHandler) {
	if h != nil {
		p.mu.Lock()
		p.createPoolHandlers = append(p.createPoolHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Shm) RemoveCreatePoolHandler(h ShmCreatePoolHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createPoolHandlers {
		if e == h {
			p.createPoolHandlers = append(p.createPoolHandlers[:i], p.createPoolHandlers[i+1:]...)
			break
		}
	}
}

func (p *Shm) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.createPoolHandlers) > 0 {
			ev := ShmCreatePoolEvent{}
			ev.Id = NewShmPool(p.Context(), int(event.Uint32()))
			ev.Fd = p.Context().NextFD()
			ev.Size = event.Int32()
			p.mu.RLock()
			for _, h := range p.createPoolHandlers {
				h.HandleShmCreatePool(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Shm struct {
	BaseProxy
	mu                 sync.RWMutex
	createPoolHandlers []ShmCreatePoolHandler
}

func NewShm(ctx *Context, id int) *Shm {
	ret := new(Shm)
	ctx.RegisterId(ret, id)
	return ret
}

// Format will pixel format description.
//
//
// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
//
func (p *Shm) Format(format uint32) error {
	return p.Context().SendRequest(p, 0, format)
}

const (
	ShmErrorInvalidFormat = 0
	ShmErrorInvalidStride = 1
	ShmErrorInvalidFd     = 2
)

const (
	ShmFormatArgb8888    = 0
	ShmFormatXrgb8888    = 1
	ShmFormatC8          = 0x20203843
	ShmFormatRgb332      = 0x38424752
	ShmFormatBgr233      = 0x38524742
	ShmFormatXrgb4444    = 0x32315258
	ShmFormatXbgr4444    = 0x32314258
	ShmFormatRgbx4444    = 0x32315852
	ShmFormatBgrx4444    = 0x32315842
	ShmFormatArgb4444    = 0x32315241
	ShmFormatAbgr4444    = 0x32314241
	ShmFormatRgba4444    = 0x32314152
	ShmFormatBgra4444    = 0x32314142
	ShmFormatXrgb1555    = 0x35315258
	ShmFormatXbgr1555    = 0x35314258
	ShmFormatRgbx5551    = 0x35315852
	ShmFormatBgrx5551    = 0x35315842
	ShmFormatArgb1555    = 0x35315241
	ShmFormatAbgr1555    = 0x35314241
	ShmFormatRgba5551    = 0x35314152
	ShmFormatBgra5551    = 0x35314142
	ShmFormatRgb565      = 0x36314752
	ShmFormatBgr565      = 0x36314742
	ShmFormatRgb888      = 0x34324752
	ShmFormatBgr888      = 0x34324742
	ShmFormatXbgr8888    = 0x34324258
	ShmFormatRgbx8888    = 0x34325852
	ShmFormatBgrx8888    = 0x34325842
	ShmFormatAbgr8888    = 0x34324241
	ShmFormatRgba8888    = 0x34324152
	ShmFormatBgra8888    = 0x34324142
	ShmFormatXrgb2101010 = 0x30335258
	ShmFormatXbgr2101010 = 0x30334258
	ShmFormatRgbx1010102 = 0x30335852
	ShmFormatBgrx1010102 = 0x30335842
	ShmFormatArgb2101010 = 0x30335241
	ShmFormatAbgr2101010 = 0x30334241
	ShmFormatRgba1010102 = 0x30334152
	ShmFormatBgra1010102 = 0x30334142
	ShmFormatYuyv        = 0x56595559
	ShmFormatYvyu        = 0x55595659
	ShmFormatUyvy        = 0x59565955
	ShmFormatVyuy        = 0x59555956
	ShmFormatAyuv        = 0x56555941
	ShmFormatNv12        = 0x3231564e
	ShmFormatNv21        = 0x3132564e
	ShmFormatNv16        = 0x3631564e
	ShmFormatNv61        = 0x3136564e
	ShmFormatYuv410      = 0x39565559
	ShmFormatYvu410      = 0x39555659
	ShmFormatYuv411      = 0x31315559
	ShmFormatYvu411      = 0x31315659
	ShmFormatYuv420      = 0x32315559
	ShmFormatYvu420      = 0x32315659
	ShmFormatYuv422      = 0x36315559
	ShmFormatYvu422      = 0x36315659
	ShmFormatYuv444      = 0x34325559
	ShmFormatYvu444      = 0x34325659
)

type BufferDestroyEvent struct {
}

type BufferDestroyHandler interface {
	HandleBufferDestroy(BufferDestroyEvent)
}

func (p *Buffer) AddDestroyHandler(h BufferDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Buffer) RemoveDestroyHandler(h BufferDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

func (p *Buffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := BufferDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleBufferDestroy(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Buffer struct {
	BaseProxy
	mu              sync.RWMutex
	destroyHandlers []BufferDestroyHandler
}

func NewBuffer(ctx *Context, id int) *Buffer {
	ret := new(Buffer)
	ctx.RegisterId(ret, id)
	return ret
}

// Release will compositor releases buffer.
//
//
// Sent when this wl_buffer is no longer used by the compositor.
// The client is now free to reuse or destroy this buffer and its
// backing storage.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
//
func (p *Buffer) Release() error {
	return p.Context().SendRequest(p, 0)
}

type DataOfferAcceptEvent struct {
	Serial   uint32
	MimeType string
}

type DataOfferAcceptHandler interface {
	HandleDataOfferAccept(DataOfferAcceptEvent)
}

func (p *DataOffer) AddAcceptHandler(h DataOfferAcceptHandler) {
	if h != nil {
		p.mu.Lock()
		p.acceptHandlers = append(p.acceptHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataOffer) RemoveAcceptHandler(h DataOfferAcceptHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.acceptHandlers {
		if e == h {
			p.acceptHandlers = append(p.acceptHandlers[:i], p.acceptHandlers[i+1:]...)
			break
		}
	}
}

type DataOfferReceiveEvent struct {
	MimeType string
	Fd       uintptr
}

type DataOfferReceiveHandler interface {
	HandleDataOfferReceive(DataOfferReceiveEvent)
}

func (p *DataOffer) AddReceiveHandler(h DataOfferReceiveHandler) {
	if h != nil {
		p.mu.Lock()
		p.receiveHandlers = append(p.receiveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataOffer) RemoveReceiveHandler(h DataOfferReceiveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.receiveHandlers {
		if e == h {
			p.receiveHandlers = append(p.receiveHandlers[:i], p.receiveHandlers[i+1:]...)
			break
		}
	}
}

type DataOfferDestroyEvent struct {
}

type DataOfferDestroyHandler interface {
	HandleDataOfferDestroy(DataOfferDestroyEvent)
}

func (p *DataOffer) AddDestroyHandler(h DataOfferDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataOffer) RemoveDestroyHandler(h DataOfferDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type DataOfferFinishEvent struct {
}

type DataOfferFinishHandler interface {
	HandleDataOfferFinish(DataOfferFinishEvent)
}

func (p *DataOffer) AddFinishHandler(h DataOfferFinishHandler) {
	if h != nil {
		p.mu.Lock()
		p.finishHandlers = append(p.finishHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataOffer) RemoveFinishHandler(h DataOfferFinishHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.finishHandlers {
		if e == h {
			p.finishHandlers = append(p.finishHandlers[:i], p.finishHandlers[i+1:]...)
			break
		}
	}
}

type DataOfferSetActionsEvent struct {
	DndActions      uint32
	PreferredAction uint32
}

type DataOfferSetActionsHandler interface {
	HandleDataOfferSetActions(DataOfferSetActionsEvent)
}

func (p *DataOffer) AddSetActionsHandler(h DataOfferSetActionsHandler) {
	if h != nil {
		p.mu.Lock()
		p.setActionsHandlers = append(p.setActionsHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataOffer) RemoveSetActionsHandler(h DataOfferSetActionsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setActionsHandlers {
		if e == h {
			p.setActionsHandlers = append(p.setActionsHandlers[:i], p.setActionsHandlers[i+1:]...)
			break
		}
	}
}

func (p *DataOffer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.acceptHandlers) > 0 {
			ev := DataOfferAcceptEvent{}
			ev.Serial = event.Uint32()
			ev.MimeType = event.String()
			p.mu.RLock()
			for _, h := range p.acceptHandlers {
				h.HandleDataOfferAccept(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.receiveHandlers) > 0 {
			ev := DataOfferReceiveEvent{}
			ev.MimeType = event.String()
			ev.Fd = p.Context().NextFD()
			p.mu.RLock()
			for _, h := range p.receiveHandlers {
				h.HandleDataOfferReceive(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.destroyHandlers) > 0 {
			ev := DataOfferDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleDataOfferDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.finishHandlers) > 0 {
			ev := DataOfferFinishEvent{}
			p.mu.RLock()
			for _, h := range p.finishHandlers {
				h.HandleDataOfferFinish(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setActionsHandlers) > 0 {
			ev := DataOfferSetActionsEvent{}
			ev.DndActions = event.Uint32()
			ev.PreferredAction = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setActionsHandlers {
				h.HandleDataOfferSetActions(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type DataOffer struct {
	BaseProxy
	mu                 sync.RWMutex
	acceptHandlers     []DataOfferAcceptHandler
	receiveHandlers    []DataOfferReceiveHandler
	destroyHandlers    []DataOfferDestroyHandler
	finishHandlers     []DataOfferFinishHandler
	setActionsHandlers []DataOfferSetActionsHandler
}

func NewDataOffer(ctx *Context, id int) *DataOffer {
	ret := new(DataOffer)
	ctx.RegisterId(ret, id)
	return ret
}

// Offer will advertise offered mime type.
//
//
// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
//
func (p *DataOffer) Offer(mime_type string) error {
	return p.Context().SendRequest(p, 0, mime_type)
}

// SourceActions will notify the source-side available actions.
//
//
// This event indicates the actions offered by the data source. It
// will be sent right after wl_data_device.enter, or anytime the source
// side changes its offered actions through wl_data_source.set_actions.
//
func (p *DataOffer) SourceActions(source_actions uint32) error {
	return p.Context().SendRequest(p, 1, source_actions)
}

// Action will notify the selected action.
//
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
//
func (p *DataOffer) Action(dnd_action uint32) error {
	return p.Context().SendRequest(p, 2, dnd_action)
}

const (
	DataOfferErrorInvalidFinish     = 0
	DataOfferErrorInvalidActionMask = 1
	DataOfferErrorInvalidAction     = 2
	DataOfferErrorInvalidOffer      = 3
)

type DataSourceOfferEvent struct {
	MimeType string
}

type DataSourceOfferHandler interface {
	HandleDataSourceOffer(DataSourceOfferEvent)
}

func (p *DataSource) AddOfferHandler(h DataSourceOfferHandler) {
	if h != nil {
		p.mu.Lock()
		p.offerHandlers = append(p.offerHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataSource) RemoveOfferHandler(h DataSourceOfferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.offerHandlers {
		if e == h {
			p.offerHandlers = append(p.offerHandlers[:i], p.offerHandlers[i+1:]...)
			break
		}
	}
}

type DataSourceDestroyEvent struct {
}

type DataSourceDestroyHandler interface {
	HandleDataSourceDestroy(DataSourceDestroyEvent)
}

func (p *DataSource) AddDestroyHandler(h DataSourceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataSource) RemoveDestroyHandler(h DataSourceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type DataSourceSetActionsEvent struct {
	DndActions uint32
}

type DataSourceSetActionsHandler interface {
	HandleDataSourceSetActions(DataSourceSetActionsEvent)
}

func (p *DataSource) AddSetActionsHandler(h DataSourceSetActionsHandler) {
	if h != nil {
		p.mu.Lock()
		p.setActionsHandlers = append(p.setActionsHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataSource) RemoveSetActionsHandler(h DataSourceSetActionsHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setActionsHandlers {
		if e == h {
			p.setActionsHandlers = append(p.setActionsHandlers[:i], p.setActionsHandlers[i+1:]...)
			break
		}
	}
}

func (p *DataSource) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.offerHandlers) > 0 {
			ev := DataSourceOfferEvent{}
			ev.MimeType = event.String()
			p.mu.RLock()
			for _, h := range p.offerHandlers {
				h.HandleDataSourceOffer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.destroyHandlers) > 0 {
			ev := DataSourceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleDataSourceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setActionsHandlers) > 0 {
			ev := DataSourceSetActionsEvent{}
			ev.DndActions = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setActionsHandlers {
				h.HandleDataSourceSetActions(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type DataSource struct {
	BaseProxy
	mu                 sync.RWMutex
	offerHandlers      []DataSourceOfferHandler
	destroyHandlers    []DataSourceDestroyHandler
	setActionsHandlers []DataSourceSetActionsHandler
}

func NewDataSource(ctx *Context, id int) *DataSource {
	ret := new(DataSource)
	ctx.RegisterId(ret, id)
	return ret
}

// Target will a target accepts an offered mime type.
//
//
// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
//
func (p *DataSource) Target(mime_type string) error {
	return p.Context().SendRequest(p, 0, mime_type)
}

// Send will send the data.
//
//
// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
//
func (p *DataSource) Send(mime_type string, fd uintptr) error {
	return p.Context().SendRequest(p, 1, mime_type, fd)
}

// Cancelled will selection was cancelled.
//
//
// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
//
func (p *DataSource) Cancelled() error {
	return p.Context().SendRequest(p, 2)
}

// DndDropPerformed will the drag-and-drop operation physically finished.
//
//
// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
//
func (p *DataSource) DndDropPerformed() error {
	return p.Context().SendRequest(p, 3)
}

// DndFinished will the drag-and-drop operation concluded.
//
//
// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
//
func (p *DataSource) DndFinished() error {
	return p.Context().SendRequest(p, 4)
}

// Action will notify the selected action.
//
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
//
func (p *DataSource) Action(dnd_action uint32) error {
	return p.Context().SendRequest(p, 5, dnd_action)
}

const (
	DataSourceErrorInvalidActionMask = 0
	DataSourceErrorInvalidSource     = 1
)

type DataDeviceStartDragEvent struct {
	Source *DataSource
	Origin *Surface
	Icon   *Surface
	Serial uint32
}

type DataDeviceStartDragHandler interface {
	HandleDataDeviceStartDrag(DataDeviceStartDragEvent)
}

func (p *DataDevice) AddStartDragHandler(h DataDeviceStartDragHandler) {
	if h != nil {
		p.mu.Lock()
		p.startDragHandlers = append(p.startDragHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataDevice) RemoveStartDragHandler(h DataDeviceStartDragHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.startDragHandlers {
		if e == h {
			p.startDragHandlers = append(p.startDragHandlers[:i], p.startDragHandlers[i+1:]...)
			break
		}
	}
}

type DataDeviceSetSelectionEvent struct {
	Source *DataSource
	Serial uint32
}

type DataDeviceSetSelectionHandler interface {
	HandleDataDeviceSetSelection(DataDeviceSetSelectionEvent)
}

func (p *DataDevice) AddSetSelectionHandler(h DataDeviceSetSelectionHandler) {
	if h != nil {
		p.mu.Lock()
		p.setSelectionHandlers = append(p.setSelectionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataDevice) RemoveSetSelectionHandler(h DataDeviceSetSelectionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setSelectionHandlers {
		if e == h {
			p.setSelectionHandlers = append(p.setSelectionHandlers[:i], p.setSelectionHandlers[i+1:]...)
			break
		}
	}
}

type DataDeviceReleaseEvent struct {
}

type DataDeviceReleaseHandler interface {
	HandleDataDeviceRelease(DataDeviceReleaseEvent)
}

func (p *DataDevice) AddReleaseHandler(h DataDeviceReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataDevice) RemoveReleaseHandler(h DataDeviceReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *DataDevice) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.startDragHandlers) > 0 {
			ev := DataDeviceStartDragEvent{}
			Source := event.Proxy(p.Context())
			if Source == nil {
				ev.Source = nil
			} else {
				ev.Source = Source.(*DataSource)
			}
			ev.Origin = event.Proxy(p.Context()).(*Surface)
			Icon := event.Proxy(p.Context())
			if Icon == nil {
				ev.Icon = nil
			} else {
				ev.Icon = Icon.(*Surface)
			}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.startDragHandlers {
				h.HandleDataDeviceStartDrag(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setSelectionHandlers) > 0 {
			ev := DataDeviceSetSelectionEvent{}
			Source := event.Proxy(p.Context())
			if Source == nil {
				ev.Source = nil
			} else {
				ev.Source = Source.(*DataSource)
			}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setSelectionHandlers {
				h.HandleDataDeviceSetSelection(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.releaseHandlers) > 0 {
			ev := DataDeviceReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandleDataDeviceRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type DataDevice struct {
	BaseProxy
	mu                   sync.RWMutex
	startDragHandlers    []DataDeviceStartDragHandler
	setSelectionHandlers []DataDeviceSetSelectionHandler
	releaseHandlers      []DataDeviceReleaseHandler
}

func NewDataDevice(ctx *Context, id int) *DataDevice {
	ret := new(DataDevice)
	ctx.RegisterId(ret, id)
	return ret
}

// DataOffer will introduce a new wl_data_offer.
//
//
// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device_data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
//
func (p *DataDevice) DataOffer() (*DataOffer, error) {
	ret := NewDataOffer(p.Context(), 223344)
	return ret, p.Context().SendRequest(p, 0, Proxy(ret))
}

// Enter will initiate drag-and-drop session.
//
//
// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
//
func (p *DataDevice) Enter(serial uint32, surface *Surface, x float32, y float32, id *DataOffer) error {
	return p.Context().SendRequest(p, 1, serial, surface, x, y, id)
}

// Leave will end drag-and-drop session.
//
//
// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
//
func (p *DataDevice) Leave() error {
	return p.Context().SendRequest(p, 2)
}

// Motion will drag-and-drop session motion.
//
//
// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
//
func (p *DataDevice) Motion(time uint32, x float32, y float32) error {
	return p.Context().SendRequest(p, 3, time, x, y)
}

// Drop will end drag-and-drop session successfully.
//
//
// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
//
func (p *DataDevice) Drop() error {
	return p.Context().SendRequest(p, 4)
}

// Selection will advertise new selection.
//
//
// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  The client must
// destroy the previous selection data_offer, if any, upon receiving
// this event.
//
func (p *DataDevice) Selection(id *DataOffer) error {
	return p.Context().SendRequest(p, 5, id)
}

const (
	DataDeviceErrorRole = 0
)

type DataDeviceManagerCreateDataSourceEvent struct {
	Id *DataSource
}

type DataDeviceManagerCreateDataSourceHandler interface {
	HandleDataDeviceManagerCreateDataSource(DataDeviceManagerCreateDataSourceEvent)
}

func (p *DataDeviceManager) AddCreateDataSourceHandler(h DataDeviceManagerCreateDataSourceHandler) {
	if h != nil {
		p.mu.Lock()
		p.createDataSourceHandlers = append(p.createDataSourceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataDeviceManager) RemoveCreateDataSourceHandler(h DataDeviceManagerCreateDataSourceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createDataSourceHandlers {
		if e == h {
			p.createDataSourceHandlers = append(p.createDataSourceHandlers[:i], p.createDataSourceHandlers[i+1:]...)
			break
		}
	}
}

type DataDeviceManagerGetDataDeviceEvent struct {
	Id   *DataDevice
	Seat *Seat
}

type DataDeviceManagerGetDataDeviceHandler interface {
	HandleDataDeviceManagerGetDataDevice(DataDeviceManagerGetDataDeviceEvent)
}

func (p *DataDeviceManager) AddGetDataDeviceHandler(h DataDeviceManagerGetDataDeviceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getDataDeviceHandlers = append(p.getDataDeviceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *DataDeviceManager) RemoveGetDataDeviceHandler(h DataDeviceManagerGetDataDeviceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getDataDeviceHandlers {
		if e == h {
			p.getDataDeviceHandlers = append(p.getDataDeviceHandlers[:i], p.getDataDeviceHandlers[i+1:]...)
			break
		}
	}
}

func (p *DataDeviceManager) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.createDataSourceHandlers) > 0 {
			ev := DataDeviceManagerCreateDataSourceEvent{}
			ev.Id = NewDataSource(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createDataSourceHandlers {
				h.HandleDataDeviceManagerCreateDataSource(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getDataDeviceHandlers) > 0 {
			ev := DataDeviceManagerGetDataDeviceEvent{}
			ev.Id = NewDataDevice(p.Context(), int(event.Uint32()))
			ev.Seat = event.Proxy(p.Context()).(*Seat)
			p.mu.RLock()
			for _, h := range p.getDataDeviceHandlers {
				h.HandleDataDeviceManagerGetDataDevice(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type DataDeviceManager struct {
	BaseProxy
	mu                       sync.RWMutex
	createDataSourceHandlers []DataDeviceManagerCreateDataSourceHandler
	getDataDeviceHandlers    []DataDeviceManagerGetDataDeviceHandler
}

func NewDataDeviceManager(ctx *Context, id int) *DataDeviceManager {
	ret := new(DataDeviceManager)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	DataDeviceManagerDndActionNone = 0
	DataDeviceManagerDndActionCopy = 1
	DataDeviceManagerDndActionMove = 2
	DataDeviceManagerDndActionAsk  = 4
)

type ShellGetShellSurfaceEvent struct {
	Id      *ShellSurface
	Surface *Surface
}

type ShellGetShellSurfaceHandler interface {
	HandleShellGetShellSurface(ShellGetShellSurfaceEvent)
}

func (p *Shell) AddGetShellSurfaceHandler(h ShellGetShellSurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getShellSurfaceHandlers = append(p.getShellSurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Shell) RemoveGetShellSurfaceHandler(h ShellGetShellSurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getShellSurfaceHandlers {
		if e == h {
			p.getShellSurfaceHandlers = append(p.getShellSurfaceHandlers[:i], p.getShellSurfaceHandlers[i+1:]...)
			break
		}
	}
}

func (p *Shell) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.getShellSurfaceHandlers) > 0 {
			ev := ShellGetShellSurfaceEvent{}
			ev.Id = NewShellSurface(p.Context(), int(event.Uint32()))
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.getShellSurfaceHandlers {
				h.HandleShellGetShellSurface(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Shell struct {
	BaseProxy
	mu                      sync.RWMutex
	getShellSurfaceHandlers []ShellGetShellSurfaceHandler
}

func NewShell(ctx *Context, id int) *Shell {
	ret := new(Shell)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	ShellErrorRole = 0
)

type ShellSurfacePongEvent struct {
	Serial uint32
}

type ShellSurfacePongHandler interface {
	HandleShellSurfacePong(ShellSurfacePongEvent)
}

func (p *ShellSurface) AddPongHandler(h ShellSurfacePongHandler) {
	if h != nil {
		p.mu.Lock()
		p.pongHandlers = append(p.pongHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemovePongHandler(h ShellSurfacePongHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.pongHandlers {
		if e == h {
			p.pongHandlers = append(p.pongHandlers[:i], p.pongHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceMoveEvent struct {
	Seat   *Seat
	Serial uint32
}

type ShellSurfaceMoveHandler interface {
	HandleShellSurfaceMove(ShellSurfaceMoveEvent)
}

func (p *ShellSurface) AddMoveHandler(h ShellSurfaceMoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.moveHandlers = append(p.moveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveMoveHandler(h ShellSurfaceMoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.moveHandlers {
		if e == h {
			p.moveHandlers = append(p.moveHandlers[:i], p.moveHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceResizeEvent struct {
	Seat   *Seat
	Serial uint32
	Edges  uint32
}

type ShellSurfaceResizeHandler interface {
	HandleShellSurfaceResize(ShellSurfaceResizeEvent)
}

func (p *ShellSurface) AddResizeHandler(h ShellSurfaceResizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.resizeHandlers = append(p.resizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveResizeHandler(h ShellSurfaceResizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resizeHandlers {
		if e == h {
			p.resizeHandlers = append(p.resizeHandlers[:i], p.resizeHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetToplevelEvent struct {
}

type ShellSurfaceSetToplevelHandler interface {
	HandleShellSurfaceSetToplevel(ShellSurfaceSetToplevelEvent)
}

func (p *ShellSurface) AddSetToplevelHandler(h ShellSurfaceSetToplevelHandler) {
	if h != nil {
		p.mu.Lock()
		p.setToplevelHandlers = append(p.setToplevelHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetToplevelHandler(h ShellSurfaceSetToplevelHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setToplevelHandlers {
		if e == h {
			p.setToplevelHandlers = append(p.setToplevelHandlers[:i], p.setToplevelHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetTransientEvent struct {
	Parent *Surface
	X      int32
	Y      int32
	Flags  uint32
}

type ShellSurfaceSetTransientHandler interface {
	HandleShellSurfaceSetTransient(ShellSurfaceSetTransientEvent)
}

func (p *ShellSurface) AddSetTransientHandler(h ShellSurfaceSetTransientHandler) {
	if h != nil {
		p.mu.Lock()
		p.setTransientHandlers = append(p.setTransientHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetTransientHandler(h ShellSurfaceSetTransientHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setTransientHandlers {
		if e == h {
			p.setTransientHandlers = append(p.setTransientHandlers[:i], p.setTransientHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetFullscreenEvent struct {
	Method    uint32
	Framerate uint32
	Output    *Output
}

type ShellSurfaceSetFullscreenHandler interface {
	HandleShellSurfaceSetFullscreen(ShellSurfaceSetFullscreenEvent)
}

func (p *ShellSurface) AddSetFullscreenHandler(h ShellSurfaceSetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.setFullscreenHandlers = append(p.setFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetFullscreenHandler(h ShellSurfaceSetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setFullscreenHandlers {
		if e == h {
			p.setFullscreenHandlers = append(p.setFullscreenHandlers[:i], p.setFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetPopupEvent struct {
	Seat   *Seat
	Serial uint32
	Parent *Surface
	X      int32
	Y      int32
	Flags  uint32
}

type ShellSurfaceSetPopupHandler interface {
	HandleShellSurfaceSetPopup(ShellSurfaceSetPopupEvent)
}

func (p *ShellSurface) AddSetPopupHandler(h ShellSurfaceSetPopupHandler) {
	if h != nil {
		p.mu.Lock()
		p.setPopupHandlers = append(p.setPopupHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetPopupHandler(h ShellSurfaceSetPopupHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setPopupHandlers {
		if e == h {
			p.setPopupHandlers = append(p.setPopupHandlers[:i], p.setPopupHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetMaximizedEvent struct {
	Output *Output
}

type ShellSurfaceSetMaximizedHandler interface {
	HandleShellSurfaceSetMaximized(ShellSurfaceSetMaximizedEvent)
}

func (p *ShellSurface) AddSetMaximizedHandler(h ShellSurfaceSetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaximizedHandlers = append(p.setMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetMaximizedHandler(h ShellSurfaceSetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaximizedHandlers {
		if e == h {
			p.setMaximizedHandlers = append(p.setMaximizedHandlers[:i], p.setMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetTitleEvent struct {
	Title string
}

type ShellSurfaceSetTitleHandler interface {
	HandleShellSurfaceSetTitle(ShellSurfaceSetTitleEvent)
}

func (p *ShellSurface) AddSetTitleHandler(h ShellSurfaceSetTitleHandler) {
	if h != nil {
		p.mu.Lock()
		p.setTitleHandlers = append(p.setTitleHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetTitleHandler(h ShellSurfaceSetTitleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setTitleHandlers {
		if e == h {
			p.setTitleHandlers = append(p.setTitleHandlers[:i], p.setTitleHandlers[i+1:]...)
			break
		}
	}
}

type ShellSurfaceSetClassEvent struct {
	Class string
}

type ShellSurfaceSetClassHandler interface {
	HandleShellSurfaceSetClass(ShellSurfaceSetClassEvent)
}

func (p *ShellSurface) AddSetClassHandler(h ShellSurfaceSetClassHandler) {
	if h != nil {
		p.mu.Lock()
		p.setClassHandlers = append(p.setClassHandlers, h)
		p.mu.Unlock()
	}
}

func (p *ShellSurface) RemoveSetClassHandler(h ShellSurfaceSetClassHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setClassHandlers {
		if e == h {
			p.setClassHandlers = append(p.setClassHandlers[:i], p.setClassHandlers[i+1:]...)
			break
		}
	}
}

func (p *ShellSurface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.pongHandlers) > 0 {
			ev := ShellSurfacePongEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.pongHandlers {
				h.HandleShellSurfacePong(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.moveHandlers) > 0 {
			ev := ShellSurfaceMoveEvent{}
			ev.Seat = event.Proxy(p.Context()).(*Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.moveHandlers {
				h.HandleShellSurfaceMove(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.resizeHandlers) > 0 {
			ev := ShellSurfaceResizeEvent{}
			ev.Seat = event.Proxy(p.Context()).(*Seat)
			ev.Serial = event.Uint32()
			ev.Edges = event.Uint32()
			p.mu.RLock()
			for _, h := range p.resizeHandlers {
				h.HandleShellSurfaceResize(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setToplevelHandlers) > 0 {
			ev := ShellSurfaceSetToplevelEvent{}
			p.mu.RLock()
			for _, h := range p.setToplevelHandlers {
				h.HandleShellSurfaceSetToplevel(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setTransientHandlers) > 0 {
			ev := ShellSurfaceSetTransientEvent{}
			ev.Parent = event.Proxy(p.Context()).(*Surface)
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Flags = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setTransientHandlers {
				h.HandleShellSurfaceSetTransient(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.setFullscreenHandlers) > 0 {
			ev := ShellSurfaceSetFullscreenEvent{}
			ev.Method = event.Uint32()
			ev.Framerate = event.Uint32()
			Output := event.Proxy(p.Context())
			if Output == nil {
				ev.Output = nil
			} else {
				ev.Output = Output.(*Output)
			}
			p.mu.RLock()
			for _, h := range p.setFullscreenHandlers {
				h.HandleShellSurfaceSetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.setPopupHandlers) > 0 {
			ev := ShellSurfaceSetPopupEvent{}
			ev.Seat = event.Proxy(p.Context()).(*Seat)
			ev.Serial = event.Uint32()
			ev.Parent = event.Proxy(p.Context()).(*Surface)
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Flags = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setPopupHandlers {
				h.HandleShellSurfaceSetPopup(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.setMaximizedHandlers) > 0 {
			ev := ShellSurfaceSetMaximizedEvent{}
			Output := event.Proxy(p.Context())
			if Output == nil {
				ev.Output = nil
			} else {
				ev.Output = Output.(*Output)
			}
			p.mu.RLock()
			for _, h := range p.setMaximizedHandlers {
				h.HandleShellSurfaceSetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.setTitleHandlers) > 0 {
			ev := ShellSurfaceSetTitleEvent{}
			ev.Title = event.String()
			p.mu.RLock()
			for _, h := range p.setTitleHandlers {
				h.HandleShellSurfaceSetTitle(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.setClassHandlers) > 0 {
			ev := ShellSurfaceSetClassEvent{}
			ev.Class = event.String()
			p.mu.RLock()
			for _, h := range p.setClassHandlers {
				h.HandleShellSurfaceSetClass(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type ShellSurface struct {
	BaseProxy
	mu                    sync.RWMutex
	pongHandlers          []ShellSurfacePongHandler
	moveHandlers          []ShellSurfaceMoveHandler
	resizeHandlers        []ShellSurfaceResizeHandler
	setToplevelHandlers   []ShellSurfaceSetToplevelHandler
	setTransientHandlers  []ShellSurfaceSetTransientHandler
	setFullscreenHandlers []ShellSurfaceSetFullscreenHandler
	setPopupHandlers      []ShellSurfaceSetPopupHandler
	setMaximizedHandlers  []ShellSurfaceSetMaximizedHandler
	setTitleHandlers      []ShellSurfaceSetTitleHandler
	setClassHandlers      []ShellSurfaceSetClassHandler
}

func NewShellSurface(ctx *Context, id int) *ShellSurface {
	ret := new(ShellSurface)
	ctx.RegisterId(ret, id)
	return ret
}

// Ping will ping client.
//
//
// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
//
func (p *ShellSurface) Ping(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

// Configure will suggest resize.
//
//
// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
//
func (p *ShellSurface) Configure(edges uint32, width int32, height int32) error {
	return p.Context().SendRequest(p, 1, edges, width, height)
}

// PopupDone will popup interaction is done.
//
//
// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
//
func (p *ShellSurface) PopupDone() error {
	return p.Context().SendRequest(p, 2)
}

const (
	ShellSurfaceResizeNone        = 0
	ShellSurfaceResizeTop         = 1
	ShellSurfaceResizeBottom      = 2
	ShellSurfaceResizeLeft        = 4
	ShellSurfaceResizeTopLeft     = 5
	ShellSurfaceResizeBottomLeft  = 6
	ShellSurfaceResizeRight       = 8
	ShellSurfaceResizeTopRight    = 9
	ShellSurfaceResizeBottomRight = 10
)

const (
	ShellSurfaceTransientInactive = 0x1
)

const (
	ShellSurfaceFullscreenMethodDefault = 0
	ShellSurfaceFullscreenMethodScale   = 1
	ShellSurfaceFullscreenMethodDriver  = 2
	ShellSurfaceFullscreenMethodFill    = 3
)

type SurfaceDestroyEvent struct {
}

type SurfaceDestroyHandler interface {
	HandleSurfaceDestroy(SurfaceDestroyEvent)
}

func (p *Surface) AddDestroyHandler(h SurfaceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveDestroyHandler(h SurfaceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceAttachEvent struct {
	Buffer *Buffer
	X      int32
	Y      int32
}

type SurfaceAttachHandler interface {
	HandleSurfaceAttach(SurfaceAttachEvent)
}

func (p *Surface) AddAttachHandler(h SurfaceAttachHandler) {
	if h != nil {
		p.mu.Lock()
		p.attachHandlers = append(p.attachHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveAttachHandler(h SurfaceAttachHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.attachHandlers {
		if e == h {
			p.attachHandlers = append(p.attachHandlers[:i], p.attachHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceDamageEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type SurfaceDamageHandler interface {
	HandleSurfaceDamage(SurfaceDamageEvent)
}

func (p *Surface) AddDamageHandler(h SurfaceDamageHandler) {
	if h != nil {
		p.mu.Lock()
		p.damageHandlers = append(p.damageHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveDamageHandler(h SurfaceDamageHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.damageHandlers {
		if e == h {
			p.damageHandlers = append(p.damageHandlers[:i], p.damageHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceFrameEvent struct {
	Callback *Callback
}

type SurfaceFrameHandler interface {
	HandleSurfaceFrame(SurfaceFrameEvent)
}

func (p *Surface) AddFrameHandler(h SurfaceFrameHandler) {
	if h != nil {
		p.mu.Lock()
		p.frameHandlers = append(p.frameHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveFrameHandler(h SurfaceFrameHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.frameHandlers {
		if e == h {
			p.frameHandlers = append(p.frameHandlers[:i], p.frameHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceSetOpaqueRegionEvent struct {
	Region *Region
}

type SurfaceSetOpaqueRegionHandler interface {
	HandleSurfaceSetOpaqueRegion(SurfaceSetOpaqueRegionEvent)
}

func (p *Surface) AddSetOpaqueRegionHandler(h SurfaceSetOpaqueRegionHandler) {
	if h != nil {
		p.mu.Lock()
		p.setOpaqueRegionHandlers = append(p.setOpaqueRegionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveSetOpaqueRegionHandler(h SurfaceSetOpaqueRegionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setOpaqueRegionHandlers {
		if e == h {
			p.setOpaqueRegionHandlers = append(p.setOpaqueRegionHandlers[:i], p.setOpaqueRegionHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceSetInputRegionEvent struct {
	Region *Region
}

type SurfaceSetInputRegionHandler interface {
	HandleSurfaceSetInputRegion(SurfaceSetInputRegionEvent)
}

func (p *Surface) AddSetInputRegionHandler(h SurfaceSetInputRegionHandler) {
	if h != nil {
		p.mu.Lock()
		p.setInputRegionHandlers = append(p.setInputRegionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveSetInputRegionHandler(h SurfaceSetInputRegionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setInputRegionHandlers {
		if e == h {
			p.setInputRegionHandlers = append(p.setInputRegionHandlers[:i], p.setInputRegionHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceCommitEvent struct {
}

type SurfaceCommitHandler interface {
	HandleSurfaceCommit(SurfaceCommitEvent)
}

func (p *Surface) AddCommitHandler(h SurfaceCommitHandler) {
	if h != nil {
		p.mu.Lock()
		p.commitHandlers = append(p.commitHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveCommitHandler(h SurfaceCommitHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.commitHandlers {
		if e == h {
			p.commitHandlers = append(p.commitHandlers[:i], p.commitHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceSetBufferTransformEvent struct {
	Transform int32
}

type SurfaceSetBufferTransformHandler interface {
	HandleSurfaceSetBufferTransform(SurfaceSetBufferTransformEvent)
}

func (p *Surface) AddSetBufferTransformHandler(h SurfaceSetBufferTransformHandler) {
	if h != nil {
		p.mu.Lock()
		p.setBufferTransformHandlers = append(p.setBufferTransformHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveSetBufferTransformHandler(h SurfaceSetBufferTransformHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setBufferTransformHandlers {
		if e == h {
			p.setBufferTransformHandlers = append(p.setBufferTransformHandlers[:i], p.setBufferTransformHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceSetBufferScaleEvent struct {
	Scale int32
}

type SurfaceSetBufferScaleHandler interface {
	HandleSurfaceSetBufferScale(SurfaceSetBufferScaleEvent)
}

func (p *Surface) AddSetBufferScaleHandler(h SurfaceSetBufferScaleHandler) {
	if h != nil {
		p.mu.Lock()
		p.setBufferScaleHandlers = append(p.setBufferScaleHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveSetBufferScaleHandler(h SurfaceSetBufferScaleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setBufferScaleHandlers {
		if e == h {
			p.setBufferScaleHandlers = append(p.setBufferScaleHandlers[:i], p.setBufferScaleHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceDamageBufferEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type SurfaceDamageBufferHandler interface {
	HandleSurfaceDamageBuffer(SurfaceDamageBufferEvent)
}

func (p *Surface) AddDamageBufferHandler(h SurfaceDamageBufferHandler) {
	if h != nil {
		p.mu.Lock()
		p.damageBufferHandlers = append(p.damageBufferHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveDamageBufferHandler(h SurfaceDamageBufferHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.damageBufferHandlers {
		if e == h {
			p.damageBufferHandlers = append(p.damageBufferHandlers[:i], p.damageBufferHandlers[i+1:]...)
			break
		}
	}
}

func (p *Surface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := SurfaceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleSurfaceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.attachHandlers) > 0 {
			ev := SurfaceAttachEvent{}
			Buffer := event.Proxy(p.Context())
			if Buffer == nil {
				ev.Buffer = nil
			} else {
				ev.Buffer = Buffer.(*Buffer)
			}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.attachHandlers {
				h.HandleSurfaceAttach(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.damageHandlers) > 0 {
			ev := SurfaceDamageEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.damageHandlers {
				h.HandleSurfaceDamage(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.frameHandlers) > 0 {
			ev := SurfaceFrameEvent{}
			ev.Callback = NewCallback(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.frameHandlers {
				h.HandleSurfaceFrame(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setOpaqueRegionHandlers) > 0 {
			ev := SurfaceSetOpaqueRegionEvent{}
			Region := event.Proxy(p.Context())
			if Region == nil {
				ev.Region = nil
			} else {
				ev.Region = Region.(*Region)
			}
			p.mu.RLock()
			for _, h := range p.setOpaqueRegionHandlers {
				h.HandleSurfaceSetOpaqueRegion(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.setInputRegionHandlers) > 0 {
			ev := SurfaceSetInputRegionEvent{}
			Region := event.Proxy(p.Context())
			if Region == nil {
				ev.Region = nil
			} else {
				ev.Region = Region.(*Region)
			}
			p.mu.RLock()
			for _, h := range p.setInputRegionHandlers {
				h.HandleSurfaceSetInputRegion(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.commitHandlers) > 0 {
			ev := SurfaceCommitEvent{}
			p.mu.RLock()
			for _, h := range p.commitHandlers {
				h.HandleSurfaceCommit(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.setBufferTransformHandlers) > 0 {
			ev := SurfaceSetBufferTransformEvent{}
			ev.Transform = event.Int32()
			p.mu.RLock()
			for _, h := range p.setBufferTransformHandlers {
				h.HandleSurfaceSetBufferTransform(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.setBufferScaleHandlers) > 0 {
			ev := SurfaceSetBufferScaleEvent{}
			ev.Scale = event.Int32()
			p.mu.RLock()
			for _, h := range p.setBufferScaleHandlers {
				h.HandleSurfaceSetBufferScale(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.damageBufferHandlers) > 0 {
			ev := SurfaceDamageBufferEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.damageBufferHandlers {
				h.HandleSurfaceDamageBuffer(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Surface struct {
	BaseProxy
	mu                         sync.RWMutex
	destroyHandlers            []SurfaceDestroyHandler
	attachHandlers             []SurfaceAttachHandler
	damageHandlers             []SurfaceDamageHandler
	frameHandlers              []SurfaceFrameHandler
	setOpaqueRegionHandlers    []SurfaceSetOpaqueRegionHandler
	setInputRegionHandlers     []SurfaceSetInputRegionHandler
	commitHandlers             []SurfaceCommitHandler
	setBufferTransformHandlers []SurfaceSetBufferTransformHandler
	setBufferScaleHandlers     []SurfaceSetBufferScaleHandler
	damageBufferHandlers       []SurfaceDamageBufferHandler
}

func NewSurface(ctx *Context, id int) *Surface {
	ret := new(Surface)
	ctx.RegisterId(ret, id)
	return ret
}

// Enter will surface enters an output.
//
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
//
func (p *Surface) Enter(output *Output) error {
	return p.Context().SendRequest(p, 0, output)
}

// Leave will surface leaves an output.
//
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
func (p *Surface) Leave(output *Output) error {
	return p.Context().SendRequest(p, 1, output)
}

const (
	SurfaceErrorInvalidScale     = 0
	SurfaceErrorInvalidTransform = 1
)

type SeatGetPointerEvent struct {
	Id *Pointer
}

type SeatGetPointerHandler interface {
	HandleSeatGetPointer(SeatGetPointerEvent)
}

func (p *Seat) AddGetPointerHandler(h SeatGetPointerHandler) {
	if h != nil {
		p.mu.Lock()
		p.getPointerHandlers = append(p.getPointerHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Seat) RemoveGetPointerHandler(h SeatGetPointerHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getPointerHandlers {
		if e == h {
			p.getPointerHandlers = append(p.getPointerHandlers[:i], p.getPointerHandlers[i+1:]...)
			break
		}
	}
}

type SeatGetKeyboardEvent struct {
	Id *Keyboard
}

type SeatGetKeyboardHandler interface {
	HandleSeatGetKeyboard(SeatGetKeyboardEvent)
}

func (p *Seat) AddGetKeyboardHandler(h SeatGetKeyboardHandler) {
	if h != nil {
		p.mu.Lock()
		p.getKeyboardHandlers = append(p.getKeyboardHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Seat) RemoveGetKeyboardHandler(h SeatGetKeyboardHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getKeyboardHandlers {
		if e == h {
			p.getKeyboardHandlers = append(p.getKeyboardHandlers[:i], p.getKeyboardHandlers[i+1:]...)
			break
		}
	}
}

type SeatGetTouchEvent struct {
	Id *Touch
}

type SeatGetTouchHandler interface {
	HandleSeatGetTouch(SeatGetTouchEvent)
}

func (p *Seat) AddGetTouchHandler(h SeatGetTouchHandler) {
	if h != nil {
		p.mu.Lock()
		p.getTouchHandlers = append(p.getTouchHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Seat) RemoveGetTouchHandler(h SeatGetTouchHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getTouchHandlers {
		if e == h {
			p.getTouchHandlers = append(p.getTouchHandlers[:i], p.getTouchHandlers[i+1:]...)
			break
		}
	}
}

type SeatReleaseEvent struct {
}

type SeatReleaseHandler interface {
	HandleSeatRelease(SeatReleaseEvent)
}

func (p *Seat) AddReleaseHandler(h SeatReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Seat) RemoveReleaseHandler(h SeatReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *Seat) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.getPointerHandlers) > 0 {
			ev := SeatGetPointerEvent{}
			ev.Id = NewPointer(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getPointerHandlers {
				h.HandleSeatGetPointer(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getKeyboardHandlers) > 0 {
			ev := SeatGetKeyboardEvent{}
			ev.Id = NewKeyboard(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getKeyboardHandlers {
				h.HandleSeatGetKeyboard(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getTouchHandlers) > 0 {
			ev := SeatGetTouchEvent{}
			ev.Id = NewTouch(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getTouchHandlers {
				h.HandleSeatGetTouch(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.releaseHandlers) > 0 {
			ev := SeatReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandleSeatRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Seat struct {
	BaseProxy
	mu                  sync.RWMutex
	getPointerHandlers  []SeatGetPointerHandler
	getKeyboardHandlers []SeatGetKeyboardHandler
	getTouchHandlers    []SeatGetTouchHandler
	releaseHandlers     []SeatReleaseHandler
}

func NewSeat(ctx *Context, id int) *Seat {
	ret := new(Seat)
	ctx.RegisterId(ret, id)
	return ret
}

// Capabilities will seat capabilities changed.
//
//
// This is emitted whenever a seat gains or loses the pointer,
// keyboard or touch capabilities.  The argument is a capability
// enum containing the complete set of capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
//
func (p *Seat) Capabilities(capabilities uint32) error {
	return p.Context().SendRequest(p, 0, capabilities)
}

// Name will unique identifier for this seat.
//
//
// In a multiseat configuration this can be used by the client to help
// identify which physical devices the seat represents. Based on
// the seat configuration used by the compositor.
//
func (p *Seat) Name(name string) error {
	return p.Context().SendRequest(p, 1, name)
}

const (
	SeatCapabilityPointer  = 1
	SeatCapabilityKeyboard = 2
	SeatCapabilityTouch    = 4
)

type PointerSetCursorEvent struct {
	Serial   uint32
	Surface  *Surface
	HotspotX int32
	HotspotY int32
}

type PointerSetCursorHandler interface {
	HandlePointerSetCursor(PointerSetCursorEvent)
}

func (p *Pointer) AddSetCursorHandler(h PointerSetCursorHandler) {
	if h != nil {
		p.mu.Lock()
		p.setCursorHandlers = append(p.setCursorHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Pointer) RemoveSetCursorHandler(h PointerSetCursorHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setCursorHandlers {
		if e == h {
			p.setCursorHandlers = append(p.setCursorHandlers[:i], p.setCursorHandlers[i+1:]...)
			break
		}
	}
}

type PointerReleaseEvent struct {
}

type PointerReleaseHandler interface {
	HandlePointerRelease(PointerReleaseEvent)
}

func (p *Pointer) AddReleaseHandler(h PointerReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Pointer) RemoveReleaseHandler(h PointerReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *Pointer) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.setCursorHandlers) > 0 {
			ev := PointerSetCursorEvent{}
			ev.Serial = event.Uint32()
			Surface := event.Proxy(p.Context())
			if Surface == nil {
				ev.Surface = nil
			} else {
				ev.Surface = Surface.(*Surface)
			}
			ev.HotspotX = event.Int32()
			ev.HotspotY = event.Int32()
			p.mu.RLock()
			for _, h := range p.setCursorHandlers {
				h.HandlePointerSetCursor(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.releaseHandlers) > 0 {
			ev := PointerReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandlePointerRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Pointer struct {
	BaseProxy
	mu                sync.RWMutex
	setCursorHandlers []PointerSetCursorHandler
	releaseHandlers   []PointerReleaseHandler
}

func NewPointer(ctx *Context, id int) *Pointer {
	ret := new(Pointer)
	ctx.RegisterId(ret, id)
	return ret
}

// Enter will enter event.
//
//
// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
//
func (p *Pointer) Enter(serial uint32, surface *Surface, surface_x float32, surface_y float32) error {
	return p.Context().SendRequest(p, 0, serial, surface, surface_x, surface_y)
}

// Leave will leave event.
//
//
// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
func (p *Pointer) Leave(serial uint32, surface *Surface) error {
	return p.Context().SendRequest(p, 1, serial, surface)
}

// Motion will pointer motion event.
//
//
// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
//
func (p *Pointer) Motion(time uint32, surface_x float32, surface_y float32) error {
	return p.Context().SendRequest(p, 2, time, surface_x, surface_y)
}

// Button will pointer button event.
//
//
// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
//
func (p *Pointer) Button(serial uint32, time uint32, button uint32, state uint32) error {
	return p.Context().SendRequest(p, 3, serial, time, button, state)
}

// Axis will axis event.
//
//
// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
//
func (p *Pointer) Axis(time uint32, axis uint32, value float32) error {
	return p.Context().SendRequest(p, 4, time, axis, value)
}

// Frame will end of a pointer event sequence.
//
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
//
func (p *Pointer) Frame() error {
	return p.Context().SendRequest(p, 5)
}

// AxisSource will axis source event.
//
//
// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
//
func (p *Pointer) AxisSource(axis_source uint32) error {
	return p.Context().SendRequest(p, 6, axis_source)
}

// AxisStop will axis stop event.
//
//
// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
//
func (p *Pointer) AxisStop(time uint32, axis uint32) error {
	return p.Context().SendRequest(p, 7, time, axis)
}

// AxisDiscrete will axis click event.
//
//
// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
//
func (p *Pointer) AxisDiscrete(axis uint32, discrete int32) error {
	return p.Context().SendRequest(p, 8, axis, discrete)
}

const (
	PointerErrorRole = 0
)

const (
	PointerButtonStateReleased = 0
	PointerButtonStatePressed  = 1
)

const (
	PointerAxisVerticalScroll   = 0
	PointerAxisHorizontalScroll = 1
)

const (
	PointerAxisSourceWheel      = 0
	PointerAxisSourceFinger     = 1
	PointerAxisSourceContinuous = 2
	PointerAxisSourceWheelTilt  = 3
)

type KeyboardReleaseEvent struct {
}

type KeyboardReleaseHandler interface {
	HandleKeyboardRelease(KeyboardReleaseEvent)
}

func (p *Keyboard) AddReleaseHandler(h KeyboardReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Keyboard) RemoveReleaseHandler(h KeyboardReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *Keyboard) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.releaseHandlers) > 0 {
			ev := KeyboardReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandleKeyboardRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Keyboard struct {
	BaseProxy
	mu              sync.RWMutex
	releaseHandlers []KeyboardReleaseHandler
}

func NewKeyboard(ctx *Context, id int) *Keyboard {
	ret := new(Keyboard)
	ctx.RegisterId(ret, id)
	return ret
}

// Keymap will keyboard mapping.
//
//
// This event provides a file descriptor to the client which can be
// memory-mapped to provide a keyboard mapping description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
//
func (p *Keyboard) Keymap(format uint32, fd uintptr, size uint32) error {
	return p.Context().SendRequest(p, 0, format, fd, size)
}

// Enter will enter event.
//
//
// Notification that this seat's keyboard focus is on a certain
// surface.
//
func (p *Keyboard) Enter(serial uint32, surface *Surface, keys []int32) error {
	return p.Context().SendRequest(p, 1, serial, surface, keys)
}

// Leave will leave event.
//
//
// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
func (p *Keyboard) Leave(serial uint32, surface *Surface) error {
	return p.Context().SendRequest(p, 2, serial, surface)
}

// Key will key event.
//
//
// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
func (p *Keyboard) Key(serial uint32, time uint32, key uint32, state uint32) error {
	return p.Context().SendRequest(p, 3, serial, time, key, state)
}

// Modifiers will modifier and group state.
//
//
// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
//
func (p *Keyboard) Modifiers(serial uint32, mods_depressed uint32, mods_latched uint32, mods_locked uint32, group uint32) error {
	return p.Context().SendRequest(p, 4, serial, mods_depressed, mods_latched, mods_locked, group)
}

// RepeatInfo will repeat rate and delay.
//
//
// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
//
func (p *Keyboard) RepeatInfo(rate int32, delay int32) error {
	return p.Context().SendRequest(p, 5, rate, delay)
}

const (
	KeyboardKeymapFormatNoKeymap = 0
	KeyboardKeymapFormatXkbV1    = 1
)

const (
	KeyboardKeyStateReleased = 0
	KeyboardKeyStatePressed  = 1
)

type TouchReleaseEvent struct {
}

type TouchReleaseHandler interface {
	HandleTouchRelease(TouchReleaseEvent)
}

func (p *Touch) AddReleaseHandler(h TouchReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Touch) RemoveReleaseHandler(h TouchReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *Touch) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.releaseHandlers) > 0 {
			ev := TouchReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandleTouchRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Touch struct {
	BaseProxy
	mu              sync.RWMutex
	releaseHandlers []TouchReleaseHandler
}

func NewTouch(ctx *Context, id int) *Touch {
	ret := new(Touch)
	ctx.RegisterId(ret, id)
	return ret
}

// Down will touch down event and beginning of a touch sequence.
//
//
// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
//
func (p *Touch) Down(serial uint32, time uint32, surface *Surface, id int32, x float32, y float32) error {
	return p.Context().SendRequest(p, 0, serial, time, surface, id, x, y)
}

// Up will end of a touch event sequence.
//
//
// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
//
func (p *Touch) Up(serial uint32, time uint32, id int32) error {
	return p.Context().SendRequest(p, 1, serial, time, id)
}

// Motion will update of touch point coordinates.
//
//
// A touch point has changed coordinates.
//
func (p *Touch) Motion(time uint32, id int32, x float32, y float32) error {
	return p.Context().SendRequest(p, 2, time, id, x, y)
}

// Frame will end of touch frame event.
//
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
//
func (p *Touch) Frame() error {
	return p.Context().SendRequest(p, 3)
}

// Cancel will touch session cancelled.
//
//
// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
//
func (p *Touch) Cancel() error {
	return p.Context().SendRequest(p, 4)
}

// Shape will update shape of touch point.
//
//
// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
//
func (p *Touch) Shape(id int32, major float32, minor float32) error {
	return p.Context().SendRequest(p, 5, id, major, minor)
}

// Orientation will update orientation of touch point.
//
//
// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
//
func (p *Touch) Orientation(id int32, orientation float32) error {
	return p.Context().SendRequest(p, 6, id, orientation)
}

type OutputReleaseEvent struct {
}

type OutputReleaseHandler interface {
	HandleOutputRelease(OutputReleaseEvent)
}

func (p *Output) AddReleaseHandler(h OutputReleaseHandler) {
	if h != nil {
		p.mu.Lock()
		p.releaseHandlers = append(p.releaseHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Output) RemoveReleaseHandler(h OutputReleaseHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.releaseHandlers {
		if e == h {
			p.releaseHandlers = append(p.releaseHandlers[:i], p.releaseHandlers[i+1:]...)
			break
		}
	}
}

func (p *Output) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.releaseHandlers) > 0 {
			ev := OutputReleaseEvent{}
			p.mu.RLock()
			for _, h := range p.releaseHandlers {
				h.HandleOutputRelease(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Output struct {
	BaseProxy
	mu              sync.RWMutex
	releaseHandlers []OutputReleaseHandler
}

func NewOutput(ctx *Context, id int) *Output {
	ret := new(Output)
	ctx.RegisterId(ret, id)
	return ret
}

// Geometry will properties of the output.
//
//
// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use xdg_output.name and xdg_output.description.
//
func (p *Output) Geometry(x int32, y int32, physical_width int32, physical_height int32, subpixel int32, make string, model string, transform int32) error {
	return p.Context().SendRequest(p, 0, x, y, physical_width, physical_height, subpixel, make, model, transform)
}

// Mode will advertise available modes for the output.
//
//
// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
//
func (p *Output) Mode(flags uint32, width int32, height int32, refresh int32) error {
	return p.Context().SendRequest(p, 1, flags, width, height, refresh)
}

// Done will sent all information about output.
//
//
// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
//
func (p *Output) Done() error {
	return p.Context().SendRequest(p, 2)
}

// Scale will output scaling properties.
//
//
// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. If it is not sent, the client should assume a
// scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// It is intended that scaling aware clients track the
// current output of a surface, and if it is on a scaled
// output it should use wl_surface.set_buffer_scale with
// the scale of the output. That way the compositor can
// avoid scaling the surface, and the client can supply
// a higher detail image.
//
func (p *Output) Scale(factor int32) error {
	return p.Context().SendRequest(p, 3, factor)
}

const (
	OutputSubpixelUnknown       = 0
	OutputSubpixelNone          = 1
	OutputSubpixelHorizontalRgb = 2
	OutputSubpixelHorizontalBgr = 3
	OutputSubpixelVerticalRgb   = 4
	OutputSubpixelVerticalBgr   = 5
)

const (
	OutputTransformNormal     = 0
	OutputTransform90         = 1
	OutputTransform180        = 2
	OutputTransform270        = 3
	OutputTransformFlipped    = 4
	OutputTransformFlipped90  = 5
	OutputTransformFlipped180 = 6
	OutputTransformFlipped270 = 7
)

const (
	OutputModeCurrent   = 0x1
	OutputModePreferred = 0x2
)

type RegionDestroyEvent struct {
}

type RegionDestroyHandler interface {
	HandleRegionDestroy(RegionDestroyEvent)
}

func (p *Region) AddDestroyHandler(h RegionDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Region) RemoveDestroyHandler(h RegionDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type RegionAddEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type RegionAddHandler interface {
	HandleRegionAdd(RegionAddEvent)
}

func (p *Region) AddAddHandler(h RegionAddHandler) {
	if h != nil {
		p.mu.Lock()
		p.addHandlers = append(p.addHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Region) RemoveAddHandler(h RegionAddHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.addHandlers {
		if e == h {
			p.addHandlers = append(p.addHandlers[:i], p.addHandlers[i+1:]...)
			break
		}
	}
}

type RegionSubtractEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type RegionSubtractHandler interface {
	HandleRegionSubtract(RegionSubtractEvent)
}

func (p *Region) AddSubtractHandler(h RegionSubtractHandler) {
	if h != nil {
		p.mu.Lock()
		p.subtractHandlers = append(p.subtractHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Region) RemoveSubtractHandler(h RegionSubtractHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.subtractHandlers {
		if e == h {
			p.subtractHandlers = append(p.subtractHandlers[:i], p.subtractHandlers[i+1:]...)
			break
		}
	}
}

func (p *Region) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := RegionDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleRegionDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.addHandlers) > 0 {
			ev := RegionAddEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.addHandlers {
				h.HandleRegionAdd(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.subtractHandlers) > 0 {
			ev := RegionSubtractEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.subtractHandlers {
				h.HandleRegionSubtract(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Region struct {
	BaseProxy
	mu               sync.RWMutex
	destroyHandlers  []RegionDestroyHandler
	addHandlers      []RegionAddHandler
	subtractHandlers []RegionSubtractHandler
}

func NewRegion(ctx *Context, id int) *Region {
	ret := new(Region)
	ctx.RegisterId(ret, id)
	return ret
}

type SubcompositorDestroyEvent struct {
}

type SubcompositorDestroyHandler interface {
	HandleSubcompositorDestroy(SubcompositorDestroyEvent)
}

func (p *Subcompositor) AddDestroyHandler(h SubcompositorDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subcompositor) RemoveDestroyHandler(h SubcompositorDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type SubcompositorGetSubsurfaceEvent struct {
	Id      *Subsurface
	Surface *Surface
	Parent  *Surface
}

type SubcompositorGetSubsurfaceHandler interface {
	HandleSubcompositorGetSubsurface(SubcompositorGetSubsurfaceEvent)
}

func (p *Subcompositor) AddGetSubsurfaceHandler(h SubcompositorGetSubsurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getSubsurfaceHandlers = append(p.getSubsurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subcompositor) RemoveGetSubsurfaceHandler(h SubcompositorGetSubsurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getSubsurfaceHandlers {
		if e == h {
			p.getSubsurfaceHandlers = append(p.getSubsurfaceHandlers[:i], p.getSubsurfaceHandlers[i+1:]...)
			break
		}
	}
}

func (p *Subcompositor) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := SubcompositorDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleSubcompositorDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getSubsurfaceHandlers) > 0 {
			ev := SubcompositorGetSubsurfaceEvent{}
			ev.Id = NewSubsurface(p.Context(), int(event.Uint32()))
			ev.Surface = event.Proxy(p.Context()).(*Surface)
			ev.Parent = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.getSubsurfaceHandlers {
				h.HandleSubcompositorGetSubsurface(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Subcompositor struct {
	BaseProxy
	mu                    sync.RWMutex
	destroyHandlers       []SubcompositorDestroyHandler
	getSubsurfaceHandlers []SubcompositorGetSubsurfaceHandler
}

func NewSubcompositor(ctx *Context, id int) *Subcompositor {
	ret := new(Subcompositor)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	SubcompositorErrorBadSurface = 0
)

type SubsurfaceDestroyEvent struct {
}

type SubsurfaceDestroyHandler interface {
	HandleSubsurfaceDestroy(SubsurfaceDestroyEvent)
}

func (p *Subsurface) AddDestroyHandler(h SubsurfaceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemoveDestroyHandler(h SubsurfaceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type SubsurfaceSetPositionEvent struct {
	X int32
	Y int32
}

type SubsurfaceSetPositionHandler interface {
	HandleSubsurfaceSetPosition(SubsurfaceSetPositionEvent)
}

func (p *Subsurface) AddSetPositionHandler(h SubsurfaceSetPositionHandler) {
	if h != nil {
		p.mu.Lock()
		p.setPositionHandlers = append(p.setPositionHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemoveSetPositionHandler(h SubsurfaceSetPositionHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setPositionHandlers {
		if e == h {
			p.setPositionHandlers = append(p.setPositionHandlers[:i], p.setPositionHandlers[i+1:]...)
			break
		}
	}
}

type SubsurfacePlaceAboveEvent struct {
	Sibling *Surface
}

type SubsurfacePlaceAboveHandler interface {
	HandleSubsurfacePlaceAbove(SubsurfacePlaceAboveEvent)
}

func (p *Subsurface) AddPlaceAboveHandler(h SubsurfacePlaceAboveHandler) {
	if h != nil {
		p.mu.Lock()
		p.placeAboveHandlers = append(p.placeAboveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemovePlaceAboveHandler(h SubsurfacePlaceAboveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.placeAboveHandlers {
		if e == h {
			p.placeAboveHandlers = append(p.placeAboveHandlers[:i], p.placeAboveHandlers[i+1:]...)
			break
		}
	}
}

type SubsurfacePlaceBelowEvent struct {
	Sibling *Surface
}

type SubsurfacePlaceBelowHandler interface {
	HandleSubsurfacePlaceBelow(SubsurfacePlaceBelowEvent)
}

func (p *Subsurface) AddPlaceBelowHandler(h SubsurfacePlaceBelowHandler) {
	if h != nil {
		p.mu.Lock()
		p.placeBelowHandlers = append(p.placeBelowHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemovePlaceBelowHandler(h SubsurfacePlaceBelowHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.placeBelowHandlers {
		if e == h {
			p.placeBelowHandlers = append(p.placeBelowHandlers[:i], p.placeBelowHandlers[i+1:]...)
			break
		}
	}
}

type SubsurfaceSetSyncEvent struct {
}

type SubsurfaceSetSyncHandler interface {
	HandleSubsurfaceSetSync(SubsurfaceSetSyncEvent)
}

func (p *Subsurface) AddSetSyncHandler(h SubsurfaceSetSyncHandler) {
	if h != nil {
		p.mu.Lock()
		p.setSyncHandlers = append(p.setSyncHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemoveSetSyncHandler(h SubsurfaceSetSyncHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setSyncHandlers {
		if e == h {
			p.setSyncHandlers = append(p.setSyncHandlers[:i], p.setSyncHandlers[i+1:]...)
			break
		}
	}
}

type SubsurfaceSetDesyncEvent struct {
}

type SubsurfaceSetDesyncHandler interface {
	HandleSubsurfaceSetDesync(SubsurfaceSetDesyncEvent)
}

func (p *Subsurface) AddSetDesyncHandler(h SubsurfaceSetDesyncHandler) {
	if h != nil {
		p.mu.Lock()
		p.setDesyncHandlers = append(p.setDesyncHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Subsurface) RemoveSetDesyncHandler(h SubsurfaceSetDesyncHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setDesyncHandlers {
		if e == h {
			p.setDesyncHandlers = append(p.setDesyncHandlers[:i], p.setDesyncHandlers[i+1:]...)
			break
		}
	}
}

func (p *Subsurface) Dispatch(event *Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := SubsurfaceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleSubsurfaceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setPositionHandlers) > 0 {
			ev := SubsurfaceSetPositionEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.setPositionHandlers {
				h.HandleSubsurfaceSetPosition(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.placeAboveHandlers) > 0 {
			ev := SubsurfacePlaceAboveEvent{}
			ev.Sibling = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.placeAboveHandlers {
				h.HandleSubsurfacePlaceAbove(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.placeBelowHandlers) > 0 {
			ev := SubsurfacePlaceBelowEvent{}
			ev.Sibling = event.Proxy(p.Context()).(*Surface)
			p.mu.RLock()
			for _, h := range p.placeBelowHandlers {
				h.HandleSubsurfacePlaceBelow(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setSyncHandlers) > 0 {
			ev := SubsurfaceSetSyncEvent{}
			p.mu.RLock()
			for _, h := range p.setSyncHandlers {
				h.HandleSubsurfaceSetSync(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.setDesyncHandlers) > 0 {
			ev := SubsurfaceSetDesyncEvent{}
			p.mu.RLock()
			for _, h := range p.setDesyncHandlers {
				h.HandleSubsurfaceSetDesync(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Subsurface struct {
	BaseProxy
	mu                  sync.RWMutex
	destroyHandlers     []SubsurfaceDestroyHandler
	setPositionHandlers []SubsurfaceSetPositionHandler
	placeAboveHandlers  []SubsurfacePlaceAboveHandler
	placeBelowHandlers  []SubsurfacePlaceBelowHandler
	setSyncHandlers     []SubsurfaceSetSyncHandler
	setDesyncHandlers   []SubsurfaceSetDesyncHandler
}

func NewSubsurface(ctx *Context, id int) *Subsurface {
	ret := new(Subsurface)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	SubsurfaceErrorBadSurface = 0
)
