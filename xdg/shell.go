// package Xdg acts as a client for the xdg_shell wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml
// on 2020-02-27 16:43:46 -0500
package Xdg

import (
	"github.com/malcolmstill/wl"
	"sync"
)

type XdgWmBaseDestroyEvent struct {
}

type XdgWmBaseDestroyHandler interface {
	HandleXdgWmBaseDestroy(XdgWmBaseDestroyEvent)
}

func (p *XdgWmBase) AddDestroyHandler(h XdgWmBaseDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgWmBase) RemoveDestroyHandler(h XdgWmBaseDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgWmBaseCreatePositionerEvent struct {
	Id *XdgPositioner
}

type XdgWmBaseCreatePositionerHandler interface {
	HandleXdgWmBaseCreatePositioner(XdgWmBaseCreatePositionerEvent)
}

func (p *XdgWmBase) AddCreatePositionerHandler(h XdgWmBaseCreatePositionerHandler) {
	if h != nil {
		p.mu.Lock()
		p.createPositionerHandlers = append(p.createPositionerHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgWmBase) RemoveCreatePositionerHandler(h XdgWmBaseCreatePositionerHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createPositionerHandlers {
		if e == h {
			p.createPositionerHandlers = append(p.createPositionerHandlers[:i], p.createPositionerHandlers[i+1:]...)
			break
		}
	}
}

type XdgWmBaseGetXdgSurfaceEvent struct {
	Id      *XdgSurface
	Surface *wl.Surface
}

type XdgWmBaseGetXdgSurfaceHandler interface {
	HandleXdgWmBaseGetXdgSurface(XdgWmBaseGetXdgSurfaceEvent)
}

func (p *XdgWmBase) AddGetXdgSurfaceHandler(h XdgWmBaseGetXdgSurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgWmBase) RemoveGetXdgSurfaceHandler(h XdgWmBaseGetXdgSurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getXdgSurfaceHandlers {
		if e == h {
			p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers[:i], p.getXdgSurfaceHandlers[i+1:]...)
			break
		}
	}
}

type XdgWmBasePongEvent struct {
	Serial uint32
}

type XdgWmBasePongHandler interface {
	HandleXdgWmBasePong(XdgWmBasePongEvent)
}

func (p *XdgWmBase) AddPongHandler(h XdgWmBasePongHandler) {
	if h != nil {
		p.mu.Lock()
		p.pongHandlers = append(p.pongHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgWmBase) RemovePongHandler(h XdgWmBasePongHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.pongHandlers {
		if e == h {
			p.pongHandlers = append(p.pongHandlers[:i], p.pongHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgWmBase) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgWmBaseDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgWmBaseDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.createPositionerHandlers) > 0 {
			ev := XdgWmBaseCreatePositionerEvent{}
			ev.Id = NewXdgPositioner(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createPositionerHandlers {
				h.HandleXdgWmBaseCreatePositioner(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getXdgSurfaceHandlers) > 0 {
			ev := XdgWmBaseGetXdgSurfaceEvent{}
			ev.Id = NewXdgSurface(p.Context(), int(event.Uint32()))
			ev.Surface = event.Proxy(p.Context()).(*wl.Surface)
			p.mu.RLock()
			for _, h := range p.getXdgSurfaceHandlers {
				h.HandleXdgWmBaseGetXdgSurface(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.pongHandlers) > 0 {
			ev := XdgWmBasePongEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.pongHandlers {
				h.HandleXdgWmBasePong(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgWmBase struct {
	wl.BaseProxy
	mu                       sync.RWMutex
	destroyHandlers          []XdgWmBaseDestroyHandler
	createPositionerHandlers []XdgWmBaseCreatePositionerHandler
	getXdgSurfaceHandlers    []XdgWmBaseGetXdgSurfaceHandler
	pongHandlers             []XdgWmBasePongHandler
}

func NewXdgWmBase(ctx *wl.Context, id int) *XdgWmBase {
	ret := new(XdgWmBase)
	ctx.RegisterId(ret, id)
	return ret
}

// Ping will check if the client is alive.
//
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial. See xdg_wm_base.ping.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_wm_base object it created.
//
func (p *XdgWmBase) Ping(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

const (
	XdgWmBaseErrorRole                = 0
	XdgWmBaseErrorDefunctSurfaces     = 1
	XdgWmBaseErrorNotTheTopmostPopup  = 2
	XdgWmBaseErrorInvalidPopupParent  = 3
	XdgWmBaseErrorInvalidSurfaceState = 4
	XdgWmBaseErrorInvalidPositioner   = 5
)

type XdgPositionerDestroyEvent struct {
}

type XdgPositionerDestroyHandler interface {
	HandleXdgPositionerDestroy(XdgPositionerDestroyEvent)
}

func (p *XdgPositioner) AddDestroyHandler(h XdgPositionerDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveDestroyHandler(h XdgPositionerDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetSizeEvent struct {
	Width  int32
	Height int32
}

type XdgPositionerSetSizeHandler interface {
	HandleXdgPositionerSetSize(XdgPositionerSetSizeEvent)
}

func (p *XdgPositioner) AddSetSizeHandler(h XdgPositionerSetSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setSizeHandlers = append(p.setSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetSizeHandler(h XdgPositionerSetSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setSizeHandlers {
		if e == h {
			p.setSizeHandlers = append(p.setSizeHandlers[:i], p.setSizeHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetAnchorRectEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type XdgPositionerSetAnchorRectHandler interface {
	HandleXdgPositionerSetAnchorRect(XdgPositionerSetAnchorRectEvent)
}

func (p *XdgPositioner) AddSetAnchorRectHandler(h XdgPositionerSetAnchorRectHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAnchorRectHandlers = append(p.setAnchorRectHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetAnchorRectHandler(h XdgPositionerSetAnchorRectHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAnchorRectHandlers {
		if e == h {
			p.setAnchorRectHandlers = append(p.setAnchorRectHandlers[:i], p.setAnchorRectHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetAnchorEvent struct {
	Anchor uint32
}

type XdgPositionerSetAnchorHandler interface {
	HandleXdgPositionerSetAnchor(XdgPositionerSetAnchorEvent)
}

func (p *XdgPositioner) AddSetAnchorHandler(h XdgPositionerSetAnchorHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAnchorHandlers = append(p.setAnchorHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetAnchorHandler(h XdgPositionerSetAnchorHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAnchorHandlers {
		if e == h {
			p.setAnchorHandlers = append(p.setAnchorHandlers[:i], p.setAnchorHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetGravityEvent struct {
	Gravity uint32
}

type XdgPositionerSetGravityHandler interface {
	HandleXdgPositionerSetGravity(XdgPositionerSetGravityEvent)
}

func (p *XdgPositioner) AddSetGravityHandler(h XdgPositionerSetGravityHandler) {
	if h != nil {
		p.mu.Lock()
		p.setGravityHandlers = append(p.setGravityHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetGravityHandler(h XdgPositionerSetGravityHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setGravityHandlers {
		if e == h {
			p.setGravityHandlers = append(p.setGravityHandlers[:i], p.setGravityHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetConstraintAdjustmentEvent struct {
	ConstraintAdjustment uint32
}

type XdgPositionerSetConstraintAdjustmentHandler interface {
	HandleXdgPositionerSetConstraintAdjustment(XdgPositionerSetConstraintAdjustmentEvent)
}

func (p *XdgPositioner) AddSetConstraintAdjustmentHandler(h XdgPositionerSetConstraintAdjustmentHandler) {
	if h != nil {
		p.mu.Lock()
		p.setConstraintAdjustmentHandlers = append(p.setConstraintAdjustmentHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetConstraintAdjustmentHandler(h XdgPositionerSetConstraintAdjustmentHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setConstraintAdjustmentHandlers {
		if e == h {
			p.setConstraintAdjustmentHandlers = append(p.setConstraintAdjustmentHandlers[:i], p.setConstraintAdjustmentHandlers[i+1:]...)
			break
		}
	}
}

type XdgPositionerSetOffsetEvent struct {
	X int32
	Y int32
}

type XdgPositionerSetOffsetHandler interface {
	HandleXdgPositionerSetOffset(XdgPositionerSetOffsetEvent)
}

func (p *XdgPositioner) AddSetOffsetHandler(h XdgPositionerSetOffsetHandler) {
	if h != nil {
		p.mu.Lock()
		p.setOffsetHandlers = append(p.setOffsetHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPositioner) RemoveSetOffsetHandler(h XdgPositionerSetOffsetHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setOffsetHandlers {
		if e == h {
			p.setOffsetHandlers = append(p.setOffsetHandlers[:i], p.setOffsetHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgPositioner) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgPositionerDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgPositionerDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setSizeHandlers) > 0 {
			ev := XdgPositionerSetSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setSizeHandlers {
				h.HandleXdgPositionerSetSize(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setAnchorRectHandlers) > 0 {
			ev := XdgPositionerSetAnchorRectEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setAnchorRectHandlers {
				h.HandleXdgPositionerSetAnchorRect(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setAnchorHandlers) > 0 {
			ev := XdgPositionerSetAnchorEvent{}
			ev.Anchor = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setAnchorHandlers {
				h.HandleXdgPositionerSetAnchor(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setGravityHandlers) > 0 {
			ev := XdgPositionerSetGravityEvent{}
			ev.Gravity = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setGravityHandlers {
				h.HandleXdgPositionerSetGravity(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.setConstraintAdjustmentHandlers) > 0 {
			ev := XdgPositionerSetConstraintAdjustmentEvent{}
			ev.ConstraintAdjustment = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setConstraintAdjustmentHandlers {
				h.HandleXdgPositionerSetConstraintAdjustment(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.setOffsetHandlers) > 0 {
			ev := XdgPositionerSetOffsetEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.setOffsetHandlers {
				h.HandleXdgPositionerSetOffset(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgPositioner struct {
	wl.BaseProxy
	mu                              sync.RWMutex
	destroyHandlers                 []XdgPositionerDestroyHandler
	setSizeHandlers                 []XdgPositionerSetSizeHandler
	setAnchorRectHandlers           []XdgPositionerSetAnchorRectHandler
	setAnchorHandlers               []XdgPositionerSetAnchorHandler
	setGravityHandlers              []XdgPositionerSetGravityHandler
	setConstraintAdjustmentHandlers []XdgPositionerSetConstraintAdjustmentHandler
	setOffsetHandlers               []XdgPositionerSetOffsetHandler
}

func NewXdgPositioner(ctx *wl.Context, id int) *XdgPositioner {
	ret := new(XdgPositioner)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	XdgPositionerErrorInvalidInput = 0
)

const (
	XdgPositionerAnchorNone        = 0
	XdgPositionerAnchorTop         = 1
	XdgPositionerAnchorBottom      = 2
	XdgPositionerAnchorLeft        = 3
	XdgPositionerAnchorRight       = 4
	XdgPositionerAnchorTopLeft     = 5
	XdgPositionerAnchorBottomLeft  = 6
	XdgPositionerAnchorTopRight    = 7
	XdgPositionerAnchorBottomRight = 8
)

const (
	XdgPositionerGravityNone        = 0
	XdgPositionerGravityTop         = 1
	XdgPositionerGravityBottom      = 2
	XdgPositionerGravityLeft        = 3
	XdgPositionerGravityRight       = 4
	XdgPositionerGravityTopLeft     = 5
	XdgPositionerGravityBottomLeft  = 6
	XdgPositionerGravityTopRight    = 7
	XdgPositionerGravityBottomRight = 8
)

const (
	XdgPositionerConstraintAdjustmentNone    = 0
	XdgPositionerConstraintAdjustmentSlideX  = 1
	XdgPositionerConstraintAdjustmentSlideY  = 2
	XdgPositionerConstraintAdjustmentFlipX   = 4
	XdgPositionerConstraintAdjustmentFlipY   = 8
	XdgPositionerConstraintAdjustmentResizeX = 16
	XdgPositionerConstraintAdjustmentResizeY = 32
)

type XdgSurfaceDestroyEvent struct {
}

type XdgSurfaceDestroyHandler interface {
	HandleXdgSurfaceDestroy(XdgSurfaceDestroyEvent)
}

func (p *XdgSurface) AddDestroyHandler(h XdgSurfaceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveDestroyHandler(h XdgSurfaceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceGetToplevelEvent struct {
	Id *XdgToplevel
}

type XdgSurfaceGetToplevelHandler interface {
	HandleXdgSurfaceGetToplevel(XdgSurfaceGetToplevelEvent)
}

func (p *XdgSurface) AddGetToplevelHandler(h XdgSurfaceGetToplevelHandler) {
	if h != nil {
		p.mu.Lock()
		p.getToplevelHandlers = append(p.getToplevelHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveGetToplevelHandler(h XdgSurfaceGetToplevelHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getToplevelHandlers {
		if e == h {
			p.getToplevelHandlers = append(p.getToplevelHandlers[:i], p.getToplevelHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceGetPopupEvent struct {
	Id         *XdgPopup
	Parent     *XdgSurface
	Positioner *XdgPositioner
}

type XdgSurfaceGetPopupHandler interface {
	HandleXdgSurfaceGetPopup(XdgSurfaceGetPopupEvent)
}

func (p *XdgSurface) AddGetPopupHandler(h XdgSurfaceGetPopupHandler) {
	if h != nil {
		p.mu.Lock()
		p.getPopupHandlers = append(p.getPopupHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveGetPopupHandler(h XdgSurfaceGetPopupHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getPopupHandlers {
		if e == h {
			p.getPopupHandlers = append(p.getPopupHandlers[:i], p.getPopupHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceSetWindowGeometryEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type XdgSurfaceSetWindowGeometryHandler interface {
	HandleXdgSurfaceSetWindowGeometry(XdgSurfaceSetWindowGeometryEvent)
}

func (p *XdgSurface) AddSetWindowGeometryHandler(h XdgSurfaceSetWindowGeometryHandler) {
	if h != nil {
		p.mu.Lock()
		p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveSetWindowGeometryHandler(h XdgSurfaceSetWindowGeometryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setWindowGeometryHandlers {
		if e == h {
			p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers[:i], p.setWindowGeometryHandlers[i+1:]...)
			break
		}
	}
}

type XdgSurfaceAckConfigureEvent struct {
	Serial uint32
}

type XdgSurfaceAckConfigureHandler interface {
	HandleXdgSurfaceAckConfigure(XdgSurfaceAckConfigureEvent)
}

func (p *XdgSurface) AddAckConfigureHandler(h XdgSurfaceAckConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.ackConfigureHandlers = append(p.ackConfigureHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgSurface) RemoveAckConfigureHandler(h XdgSurfaceAckConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.ackConfigureHandlers {
		if e == h {
			p.ackConfigureHandlers = append(p.ackConfigureHandlers[:i], p.ackConfigureHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgSurface) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgSurfaceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgSurfaceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getToplevelHandlers) > 0 {
			ev := XdgSurfaceGetToplevelEvent{}
			ev.Id = NewXdgToplevel(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getToplevelHandlers {
				h.HandleXdgSurfaceGetToplevel(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getPopupHandlers) > 0 {
			ev := XdgSurfaceGetPopupEvent{}
			ev.Id = NewXdgPopup(p.Context(), int(event.Uint32()))
			parent := event.Proxy(p.Context())
			if parent != nil {
				ev.Parent = parent.(*XdgSurface)
			}
			ev.Positioner = event.Proxy(p.Context()).(*XdgPositioner)
			p.mu.RLock()
			for _, h := range p.getPopupHandlers {
				h.HandleXdgSurfaceGetPopup(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setWindowGeometryHandlers) > 0 {
			ev := XdgSurfaceSetWindowGeometryEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setWindowGeometryHandlers {
				h.HandleXdgSurfaceSetWindowGeometry(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.ackConfigureHandlers) > 0 {
			ev := XdgSurfaceAckConfigureEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.ackConfigureHandlers {
				h.HandleXdgSurfaceAckConfigure(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgSurface struct {
	wl.BaseProxy
	mu                        sync.RWMutex
	destroyHandlers           []XdgSurfaceDestroyHandler
	getToplevelHandlers       []XdgSurfaceGetToplevelHandler
	getPopupHandlers          []XdgSurfaceGetPopupHandler
	setWindowGeometryHandlers []XdgSurfaceSetWindowGeometryHandler
	ackConfigureHandlers      []XdgSurfaceAckConfigureHandler
}

func NewXdgSurface(ctx *wl.Context, id int) *XdgSurface {
	ret := new(XdgSurface)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will suggest a surface change.
//
//
// The configure event marks the end of a configure sequence. A configure
// sequence is a set of one or more events configuring the state of the
// xdg_surface, including the final xdg_surface.configure event.
//
// Where applicable, xdg_surface surface roles will during a configure
// sequence extend this event as a latched state sent as events before the
// xdg_surface.configure event. Such events should be considered to make up
// a set of atomically applied configuration states, where the
// xdg_surface.configure commits the accumulated state.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// If the client receives multiple configure events before it can respond
// to one, it is free to discard all but the last event it received.
//
func (p *XdgSurface) Configure(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

const (
	XdgSurfaceErrorNotConstructed     = 1
	XdgSurfaceErrorAlreadyConstructed = 2
	XdgSurfaceErrorUnconfiguredBuffer = 3
)

type XdgToplevelDestroyEvent struct {
}

type XdgToplevelDestroyHandler interface {
	HandleXdgToplevelDestroy(XdgToplevelDestroyEvent)
}

func (p *XdgToplevel) AddDestroyHandler(h XdgToplevelDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveDestroyHandler(h XdgToplevelDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetParentEvent struct {
	Parent *XdgToplevel
}

type XdgToplevelSetParentHandler interface {
	HandleXdgToplevelSetParent(XdgToplevelSetParentEvent)
}

func (p *XdgToplevel) AddSetParentHandler(h XdgToplevelSetParentHandler) {
	if h != nil {
		p.mu.Lock()
		p.setParentHandlers = append(p.setParentHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetParentHandler(h XdgToplevelSetParentHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setParentHandlers {
		if e == h {
			p.setParentHandlers = append(p.setParentHandlers[:i], p.setParentHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetTitleEvent struct {
	Title string
}

type XdgToplevelSetTitleHandler interface {
	HandleXdgToplevelSetTitle(XdgToplevelSetTitleEvent)
}

func (p *XdgToplevel) AddSetTitleHandler(h XdgToplevelSetTitleHandler) {
	if h != nil {
		p.mu.Lock()
		p.setTitleHandlers = append(p.setTitleHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetTitleHandler(h XdgToplevelSetTitleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setTitleHandlers {
		if e == h {
			p.setTitleHandlers = append(p.setTitleHandlers[:i], p.setTitleHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetAppIdEvent struct {
	AppId string
}

type XdgToplevelSetAppIdHandler interface {
	HandleXdgToplevelSetAppId(XdgToplevelSetAppIdEvent)
}

func (p *XdgToplevel) AddSetAppIdHandler(h XdgToplevelSetAppIdHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAppIdHandlers = append(p.setAppIdHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetAppIdHandler(h XdgToplevelSetAppIdHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAppIdHandlers {
		if e == h {
			p.setAppIdHandlers = append(p.setAppIdHandlers[:i], p.setAppIdHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelShowWindowMenuEvent struct {
	Seat   *wl.Seat
	Serial uint32
	X      int32
	Y      int32
}

type XdgToplevelShowWindowMenuHandler interface {
	HandleXdgToplevelShowWindowMenu(XdgToplevelShowWindowMenuEvent)
}

func (p *XdgToplevel) AddShowWindowMenuHandler(h XdgToplevelShowWindowMenuHandler) {
	if h != nil {
		p.mu.Lock()
		p.showWindowMenuHandlers = append(p.showWindowMenuHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveShowWindowMenuHandler(h XdgToplevelShowWindowMenuHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.showWindowMenuHandlers {
		if e == h {
			p.showWindowMenuHandlers = append(p.showWindowMenuHandlers[:i], p.showWindowMenuHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelMoveEvent struct {
	Seat   *wl.Seat
	Serial uint32
}

type XdgToplevelMoveHandler interface {
	HandleXdgToplevelMove(XdgToplevelMoveEvent)
}

func (p *XdgToplevel) AddMoveHandler(h XdgToplevelMoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.moveHandlers = append(p.moveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveMoveHandler(h XdgToplevelMoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.moveHandlers {
		if e == h {
			p.moveHandlers = append(p.moveHandlers[:i], p.moveHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelResizeEvent struct {
	Seat   *wl.Seat
	Serial uint32
	Edges  uint32
}

type XdgToplevelResizeHandler interface {
	HandleXdgToplevelResize(XdgToplevelResizeEvent)
}

func (p *XdgToplevel) AddResizeHandler(h XdgToplevelResizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.resizeHandlers = append(p.resizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveResizeHandler(h XdgToplevelResizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resizeHandlers {
		if e == h {
			p.resizeHandlers = append(p.resizeHandlers[:i], p.resizeHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetMaxSizeEvent struct {
	Width  int32
	Height int32
}

type XdgToplevelSetMaxSizeHandler interface {
	HandleXdgToplevelSetMaxSize(XdgToplevelSetMaxSizeEvent)
}

func (p *XdgToplevel) AddSetMaxSizeHandler(h XdgToplevelSetMaxSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaxSizeHandlers = append(p.setMaxSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetMaxSizeHandler(h XdgToplevelSetMaxSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaxSizeHandlers {
		if e == h {
			p.setMaxSizeHandlers = append(p.setMaxSizeHandlers[:i], p.setMaxSizeHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetMinSizeEvent struct {
	Width  int32
	Height int32
}

type XdgToplevelSetMinSizeHandler interface {
	HandleXdgToplevelSetMinSize(XdgToplevelSetMinSizeEvent)
}

func (p *XdgToplevel) AddSetMinSizeHandler(h XdgToplevelSetMinSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMinSizeHandlers = append(p.setMinSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetMinSizeHandler(h XdgToplevelSetMinSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMinSizeHandlers {
		if e == h {
			p.setMinSizeHandlers = append(p.setMinSizeHandlers[:i], p.setMinSizeHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetMaximizedEvent struct {
}

type XdgToplevelSetMaximizedHandler interface {
	HandleXdgToplevelSetMaximized(XdgToplevelSetMaximizedEvent)
}

func (p *XdgToplevel) AddSetMaximizedHandler(h XdgToplevelSetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaximizedHandlers = append(p.setMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetMaximizedHandler(h XdgToplevelSetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaximizedHandlers {
		if e == h {
			p.setMaximizedHandlers = append(p.setMaximizedHandlers[:i], p.setMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelUnsetMaximizedEvent struct {
}

type XdgToplevelUnsetMaximizedHandler interface {
	HandleXdgToplevelUnsetMaximized(XdgToplevelUnsetMaximizedEvent)
}

func (p *XdgToplevel) AddUnsetMaximizedHandler(h XdgToplevelUnsetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveUnsetMaximizedHandler(h XdgToplevelUnsetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetMaximizedHandlers {
		if e == h {
			p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers[:i], p.unsetMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetFullscreenEvent struct {
	Output *wl.Output
}

type XdgToplevelSetFullscreenHandler interface {
	HandleXdgToplevelSetFullscreen(XdgToplevelSetFullscreenEvent)
}

func (p *XdgToplevel) AddSetFullscreenHandler(h XdgToplevelSetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.setFullscreenHandlers = append(p.setFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetFullscreenHandler(h XdgToplevelSetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setFullscreenHandlers {
		if e == h {
			p.setFullscreenHandlers = append(p.setFullscreenHandlers[:i], p.setFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelUnsetFullscreenEvent struct {
}

type XdgToplevelUnsetFullscreenHandler interface {
	HandleXdgToplevelUnsetFullscreen(XdgToplevelUnsetFullscreenEvent)
}

func (p *XdgToplevel) AddUnsetFullscreenHandler(h XdgToplevelUnsetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveUnsetFullscreenHandler(h XdgToplevelUnsetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetFullscreenHandlers {
		if e == h {
			p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers[:i], p.unsetFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type XdgToplevelSetMinimizedEvent struct {
}

type XdgToplevelSetMinimizedHandler interface {
	HandleXdgToplevelSetMinimized(XdgToplevelSetMinimizedEvent)
}

func (p *XdgToplevel) AddSetMinimizedHandler(h XdgToplevelSetMinimizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMinimizedHandlers = append(p.setMinimizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgToplevel) RemoveSetMinimizedHandler(h XdgToplevelSetMinimizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMinimizedHandlers {
		if e == h {
			p.setMinimizedHandlers = append(p.setMinimizedHandlers[:i], p.setMinimizedHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgToplevel) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgToplevelDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgToplevelDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setParentHandlers) > 0 {
			ev := XdgToplevelSetParentEvent{}
			parent := event.Proxy(p.Context())
			if parent != nil {
				ev.Parent = parent.(*XdgToplevel)
			}
			p.mu.RLock()
			for _, h := range p.setParentHandlers {
				h.HandleXdgToplevelSetParent(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setTitleHandlers) > 0 {
			ev := XdgToplevelSetTitleEvent{}
			ev.Title = event.String()
			p.mu.RLock()
			for _, h := range p.setTitleHandlers {
				h.HandleXdgToplevelSetTitle(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setAppIdHandlers) > 0 {
			ev := XdgToplevelSetAppIdEvent{}
			ev.AppId = event.String()
			p.mu.RLock()
			for _, h := range p.setAppIdHandlers {
				h.HandleXdgToplevelSetAppId(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.showWindowMenuHandlers) > 0 {
			ev := XdgToplevelShowWindowMenuEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.showWindowMenuHandlers {
				h.HandleXdgToplevelShowWindowMenu(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.moveHandlers) > 0 {
			ev := XdgToplevelMoveEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.moveHandlers {
				h.HandleXdgToplevelMove(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.resizeHandlers) > 0 {
			ev := XdgToplevelResizeEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.Edges = event.Uint32()
			p.mu.RLock()
			for _, h := range p.resizeHandlers {
				h.HandleXdgToplevelResize(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.setMaxSizeHandlers) > 0 {
			ev := XdgToplevelSetMaxSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setMaxSizeHandlers {
				h.HandleXdgToplevelSetMaxSize(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.setMinSizeHandlers) > 0 {
			ev := XdgToplevelSetMinSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setMinSizeHandlers {
				h.HandleXdgToplevelSetMinSize(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.setMaximizedHandlers) > 0 {
			ev := XdgToplevelSetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMaximizedHandlers {
				h.HandleXdgToplevelSetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 10:
		if len(p.unsetMaximizedHandlers) > 0 {
			ev := XdgToplevelUnsetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.unsetMaximizedHandlers {
				h.HandleXdgToplevelUnsetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 11:
		if len(p.setFullscreenHandlers) > 0 {
			ev := XdgToplevelSetFullscreenEvent{}
			output := event.Proxy(p.Context())
			if output != nil {
				ev.Output = output.(*wl.Output)
			}
			p.mu.RLock()
			for _, h := range p.setFullscreenHandlers {
				h.HandleXdgToplevelSetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 12:
		if len(p.unsetFullscreenHandlers) > 0 {
			ev := XdgToplevelUnsetFullscreenEvent{}
			p.mu.RLock()
			for _, h := range p.unsetFullscreenHandlers {
				h.HandleXdgToplevelUnsetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 13:
		if len(p.setMinimizedHandlers) > 0 {
			ev := XdgToplevelSetMinimizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMinimizedHandlers {
				h.HandleXdgToplevelSetMinimized(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgToplevel struct {
	wl.BaseProxy
	mu                      sync.RWMutex
	destroyHandlers         []XdgToplevelDestroyHandler
	setParentHandlers       []XdgToplevelSetParentHandler
	setTitleHandlers        []XdgToplevelSetTitleHandler
	setAppIdHandlers        []XdgToplevelSetAppIdHandler
	showWindowMenuHandlers  []XdgToplevelShowWindowMenuHandler
	moveHandlers            []XdgToplevelMoveHandler
	resizeHandlers          []XdgToplevelResizeHandler
	setMaxSizeHandlers      []XdgToplevelSetMaxSizeHandler
	setMinSizeHandlers      []XdgToplevelSetMinSizeHandler
	setMaximizedHandlers    []XdgToplevelSetMaximizedHandler
	unsetMaximizedHandlers  []XdgToplevelUnsetMaximizedHandler
	setFullscreenHandlers   []XdgToplevelSetFullscreenHandler
	unsetFullscreenHandlers []XdgToplevelUnsetFullscreenHandler
	setMinimizedHandlers    []XdgToplevelSetMinimizedHandler
}

func NewXdgToplevel(ctx *wl.Context, id int) *XdgToplevel {
	ret := new(XdgToplevel)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will suggest a surface change.
//
//
// This configure event asks the client to resize its toplevel surface or
// to change its state. The configured state should not be applied
// immediately. See xdg_surface.configure for details.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor needs to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients must send an ack_configure in response to this event. See
// xdg_surface.configure and xdg_surface.ack_configure for details.
//
func (p *XdgToplevel) Configure(width int32, height int32, states []int32) error {
	return p.Context().SendRequest(p, 0, width, height, states)
}

// Close will surface wants to be closed.
//
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any.
//
// This is only a request that the user intends to close the
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data, etc.
//
func (p *XdgToplevel) Close() error {
	return p.Context().SendRequest(p, 1)
}

const (
	XdgToplevelResizeEdgeNone        = 0
	XdgToplevelResizeEdgeTop         = 1
	XdgToplevelResizeEdgeBottom      = 2
	XdgToplevelResizeEdgeLeft        = 4
	XdgToplevelResizeEdgeTopLeft     = 5
	XdgToplevelResizeEdgeBottomLeft  = 6
	XdgToplevelResizeEdgeRight       = 8
	XdgToplevelResizeEdgeTopRight    = 9
	XdgToplevelResizeEdgeBottomRight = 10
)

const (
	XdgToplevelStateMaximized   = 1
	XdgToplevelStateFullscreen  = 2
	XdgToplevelStateResizing    = 3
	XdgToplevelStateActivated   = 4
	XdgToplevelStateTiledLeft   = 5
	XdgToplevelStateTiledRight  = 6
	XdgToplevelStateTiledTop    = 7
	XdgToplevelStateTiledBottom = 8
)

type XdgPopupDestroyEvent struct {
}

type XdgPopupDestroyHandler interface {
	HandleXdgPopupDestroy(XdgPopupDestroyEvent)
}

func (p *XdgPopup) AddDestroyHandler(h XdgPopupDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPopup) RemoveDestroyHandler(h XdgPopupDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type XdgPopupGrabEvent struct {
	Seat   *wl.Seat
	Serial uint32
}

type XdgPopupGrabHandler interface {
	HandleXdgPopupGrab(XdgPopupGrabEvent)
}

func (p *XdgPopup) AddGrabHandler(h XdgPopupGrabHandler) {
	if h != nil {
		p.mu.Lock()
		p.grabHandlers = append(p.grabHandlers, h)
		p.mu.Unlock()
	}
}

func (p *XdgPopup) RemoveGrabHandler(h XdgPopupGrabHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.grabHandlers {
		if e == h {
			p.grabHandlers = append(p.grabHandlers[:i], p.grabHandlers[i+1:]...)
			break
		}
	}
}

func (p *XdgPopup) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := XdgPopupDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleXdgPopupDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.grabHandlers) > 0 {
			ev := XdgPopupGrabEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.grabHandlers {
				h.HandleXdgPopupGrab(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type XdgPopup struct {
	wl.BaseProxy
	mu              sync.RWMutex
	destroyHandlers []XdgPopupDestroyHandler
	grabHandlers    []XdgPopupGrabHandler
}

func NewXdgPopup(ctx *wl.Context, id int) *XdgPopup {
	ret := new(XdgPopup)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will configure the popup surface.
//
//
// This event asks the popup surface to configure itself given the
// configuration. The configured state should not be applied immediately.
// See xdg_surface.configure for details.
//
// The x and y arguments represent the position the popup was placed at
// given the xdg_positioner rule, relative to the upper left corner of the
// window geometry of the parent surface.
//
func (p *XdgPopup) Configure(x int32, y int32, width int32, height int32) error {
	return p.Context().SendRequest(p, 0, x, y, width, height)
}

// PopupDone will popup interaction is done.
//
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
//
func (p *XdgPopup) PopupDone() error {
	return p.Context().SendRequest(p, 1)
}

const (
	XdgPopupErrorInvalidGrab = 0
)
