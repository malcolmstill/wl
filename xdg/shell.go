// package xdg acts as a client for the xdg_shell wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml
// on 2020-02-26 21:25:48 -0500
package xdg

import (
	"github.com/malcolmstill/wl"
	"sync"
)

type WmBaseDestroyEvent struct {
}

type WmBaseDestroyHandler interface {
	HandleWmBaseDestroy(WmBaseDestroyEvent)
}

func (p *WmBase) AddDestroyHandler(h WmBaseDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *WmBase) RemoveDestroyHandler(h WmBaseDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type WmBaseCreatePositionerEvent struct {
	Id *Positioner
}

type WmBaseCreatePositionerHandler interface {
	HandleWmBaseCreatePositioner(WmBaseCreatePositionerEvent)
}

func (p *WmBase) AddCreatePositionerHandler(h WmBaseCreatePositionerHandler) {
	if h != nil {
		p.mu.Lock()
		p.createPositionerHandlers = append(p.createPositionerHandlers, h)
		p.mu.Unlock()
	}
}

func (p *WmBase) RemoveCreatePositionerHandler(h WmBaseCreatePositionerHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.createPositionerHandlers {
		if e == h {
			p.createPositionerHandlers = append(p.createPositionerHandlers[:i], p.createPositionerHandlers[i+1:]...)
			break
		}
	}
}

type WmBaseGetXdgSurfaceEvent struct {
	Id      *Surface
	Surface *wl.Surface
}

type WmBaseGetXdgSurfaceHandler interface {
	HandleWmBaseGetXdgSurface(WmBaseGetXdgSurfaceEvent)
}

func (p *WmBase) AddGetXdgSurfaceHandler(h WmBaseGetXdgSurfaceHandler) {
	if h != nil {
		p.mu.Lock()
		p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers, h)
		p.mu.Unlock()
	}
}

func (p *WmBase) RemoveGetXdgSurfaceHandler(h WmBaseGetXdgSurfaceHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getXdgSurfaceHandlers {
		if e == h {
			p.getXdgSurfaceHandlers = append(p.getXdgSurfaceHandlers[:i], p.getXdgSurfaceHandlers[i+1:]...)
			break
		}
	}
}

type WmBasePongEvent struct {
	Serial uint32
}

type WmBasePongHandler interface {
	HandleWmBasePong(WmBasePongEvent)
}

func (p *WmBase) AddPongHandler(h WmBasePongHandler) {
	if h != nil {
		p.mu.Lock()
		p.pongHandlers = append(p.pongHandlers, h)
		p.mu.Unlock()
	}
}

func (p *WmBase) RemovePongHandler(h WmBasePongHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.pongHandlers {
		if e == h {
			p.pongHandlers = append(p.pongHandlers[:i], p.pongHandlers[i+1:]...)
			break
		}
	}
}

func (p *WmBase) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := WmBaseDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleWmBaseDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.createPositionerHandlers) > 0 {
			ev := WmBaseCreatePositionerEvent{}
			ev.Id = NewPositioner(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.createPositionerHandlers {
				h.HandleWmBaseCreatePositioner(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getXdgSurfaceHandlers) > 0 {
			ev := WmBaseGetXdgSurfaceEvent{}
			ev.Id = NewSurface(p.Context(), int(event.Uint32()))
			ev.Surface = event.Proxy(p.Context()).(*wl.Surface)
			p.mu.RLock()
			for _, h := range p.getXdgSurfaceHandlers {
				h.HandleWmBaseGetXdgSurface(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.pongHandlers) > 0 {
			ev := WmBasePongEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.pongHandlers {
				h.HandleWmBasePong(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type WmBase struct {
	wl.BaseProxy
	mu                       sync.RWMutex
	destroyHandlers          []WmBaseDestroyHandler
	createPositionerHandlers []WmBaseCreatePositionerHandler
	getXdgSurfaceHandlers    []WmBaseGetXdgSurfaceHandler
	pongHandlers             []WmBasePongHandler
}

func NewWmBase(ctx *wl.Context, id int) *WmBase {
	ret := new(WmBase)
	ctx.RegisterId(ret, id)
	return ret
}

// Ping will check if the client is alive.
//
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial. See xdg_wm_base.ping.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_wm_base object it created.
//
func (p *WmBase) Ping(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

const (
	WmBaseErrorRole                = 0
	WmBaseErrorDefunctSurfaces     = 1
	WmBaseErrorNotTheTopmostPopup  = 2
	WmBaseErrorInvalidPopupParent  = 3
	WmBaseErrorInvalidSurfaceState = 4
	WmBaseErrorInvalidPositioner   = 5
)

type PositionerDestroyEvent struct {
}

type PositionerDestroyHandler interface {
	HandlePositionerDestroy(PositionerDestroyEvent)
}

func (p *Positioner) AddDestroyHandler(h PositionerDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveDestroyHandler(h PositionerDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetSizeEvent struct {
	Width  int32
	Height int32
}

type PositionerSetSizeHandler interface {
	HandlePositionerSetSize(PositionerSetSizeEvent)
}

func (p *Positioner) AddSetSizeHandler(h PositionerSetSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setSizeHandlers = append(p.setSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetSizeHandler(h PositionerSetSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setSizeHandlers {
		if e == h {
			p.setSizeHandlers = append(p.setSizeHandlers[:i], p.setSizeHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetAnchorRectEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type PositionerSetAnchorRectHandler interface {
	HandlePositionerSetAnchorRect(PositionerSetAnchorRectEvent)
}

func (p *Positioner) AddSetAnchorRectHandler(h PositionerSetAnchorRectHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAnchorRectHandlers = append(p.setAnchorRectHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetAnchorRectHandler(h PositionerSetAnchorRectHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAnchorRectHandlers {
		if e == h {
			p.setAnchorRectHandlers = append(p.setAnchorRectHandlers[:i], p.setAnchorRectHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetAnchorEvent struct {
	Anchor uint32
}

type PositionerSetAnchorHandler interface {
	HandlePositionerSetAnchor(PositionerSetAnchorEvent)
}

func (p *Positioner) AddSetAnchorHandler(h PositionerSetAnchorHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAnchorHandlers = append(p.setAnchorHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetAnchorHandler(h PositionerSetAnchorHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAnchorHandlers {
		if e == h {
			p.setAnchorHandlers = append(p.setAnchorHandlers[:i], p.setAnchorHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetGravityEvent struct {
	Gravity uint32
}

type PositionerSetGravityHandler interface {
	HandlePositionerSetGravity(PositionerSetGravityEvent)
}

func (p *Positioner) AddSetGravityHandler(h PositionerSetGravityHandler) {
	if h != nil {
		p.mu.Lock()
		p.setGravityHandlers = append(p.setGravityHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetGravityHandler(h PositionerSetGravityHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setGravityHandlers {
		if e == h {
			p.setGravityHandlers = append(p.setGravityHandlers[:i], p.setGravityHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetConstraintAdjustmentEvent struct {
	ConstraintAdjustment uint32
}

type PositionerSetConstraintAdjustmentHandler interface {
	HandlePositionerSetConstraintAdjustment(PositionerSetConstraintAdjustmentEvent)
}

func (p *Positioner) AddSetConstraintAdjustmentHandler(h PositionerSetConstraintAdjustmentHandler) {
	if h != nil {
		p.mu.Lock()
		p.setConstraintAdjustmentHandlers = append(p.setConstraintAdjustmentHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetConstraintAdjustmentHandler(h PositionerSetConstraintAdjustmentHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setConstraintAdjustmentHandlers {
		if e == h {
			p.setConstraintAdjustmentHandlers = append(p.setConstraintAdjustmentHandlers[:i], p.setConstraintAdjustmentHandlers[i+1:]...)
			break
		}
	}
}

type PositionerSetOffsetEvent struct {
	X int32
	Y int32
}

type PositionerSetOffsetHandler interface {
	HandlePositionerSetOffset(PositionerSetOffsetEvent)
}

func (p *Positioner) AddSetOffsetHandler(h PositionerSetOffsetHandler) {
	if h != nil {
		p.mu.Lock()
		p.setOffsetHandlers = append(p.setOffsetHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Positioner) RemoveSetOffsetHandler(h PositionerSetOffsetHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setOffsetHandlers {
		if e == h {
			p.setOffsetHandlers = append(p.setOffsetHandlers[:i], p.setOffsetHandlers[i+1:]...)
			break
		}
	}
}

func (p *Positioner) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := PositionerDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandlePositionerDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setSizeHandlers) > 0 {
			ev := PositionerSetSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setSizeHandlers {
				h.HandlePositionerSetSize(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setAnchorRectHandlers) > 0 {
			ev := PositionerSetAnchorRectEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setAnchorRectHandlers {
				h.HandlePositionerSetAnchorRect(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setAnchorHandlers) > 0 {
			ev := PositionerSetAnchorEvent{}
			ev.Anchor = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setAnchorHandlers {
				h.HandlePositionerSetAnchor(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.setGravityHandlers) > 0 {
			ev := PositionerSetGravityEvent{}
			ev.Gravity = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setGravityHandlers {
				h.HandlePositionerSetGravity(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.setConstraintAdjustmentHandlers) > 0 {
			ev := PositionerSetConstraintAdjustmentEvent{}
			ev.ConstraintAdjustment = event.Uint32()
			p.mu.RLock()
			for _, h := range p.setConstraintAdjustmentHandlers {
				h.HandlePositionerSetConstraintAdjustment(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.setOffsetHandlers) > 0 {
			ev := PositionerSetOffsetEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.setOffsetHandlers {
				h.HandlePositionerSetOffset(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Positioner struct {
	wl.BaseProxy
	mu                              sync.RWMutex
	destroyHandlers                 []PositionerDestroyHandler
	setSizeHandlers                 []PositionerSetSizeHandler
	setAnchorRectHandlers           []PositionerSetAnchorRectHandler
	setAnchorHandlers               []PositionerSetAnchorHandler
	setGravityHandlers              []PositionerSetGravityHandler
	setConstraintAdjustmentHandlers []PositionerSetConstraintAdjustmentHandler
	setOffsetHandlers               []PositionerSetOffsetHandler
}

func NewPositioner(ctx *wl.Context, id int) *Positioner {
	ret := new(Positioner)
	ctx.RegisterId(ret, id)
	return ret
}

const (
	PositionerErrorInvalidInput = 0
)

const (
	PositionerAnchorNone        = 0
	PositionerAnchorTop         = 1
	PositionerAnchorBottom      = 2
	PositionerAnchorLeft        = 3
	PositionerAnchorRight       = 4
	PositionerAnchorTopLeft     = 5
	PositionerAnchorBottomLeft  = 6
	PositionerAnchorTopRight    = 7
	PositionerAnchorBottomRight = 8
)

const (
	PositionerGravityNone        = 0
	PositionerGravityTop         = 1
	PositionerGravityBottom      = 2
	PositionerGravityLeft        = 3
	PositionerGravityRight       = 4
	PositionerGravityTopLeft     = 5
	PositionerGravityBottomLeft  = 6
	PositionerGravityTopRight    = 7
	PositionerGravityBottomRight = 8
)

const (
	PositionerConstraintAdjustmentNone    = 0
	PositionerConstraintAdjustmentSlideX  = 1
	PositionerConstraintAdjustmentSlideY  = 2
	PositionerConstraintAdjustmentFlipX   = 4
	PositionerConstraintAdjustmentFlipY   = 8
	PositionerConstraintAdjustmentResizeX = 16
	PositionerConstraintAdjustmentResizeY = 32
)

type SurfaceDestroyEvent struct {
}

type SurfaceDestroyHandler interface {
	HandleSurfaceDestroy(SurfaceDestroyEvent)
}

func (p *Surface) AddDestroyHandler(h SurfaceDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveDestroyHandler(h SurfaceDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceGetToplevelEvent struct {
	Id *Toplevel
}

type SurfaceGetToplevelHandler interface {
	HandleSurfaceGetToplevel(SurfaceGetToplevelEvent)
}

func (p *Surface) AddGetToplevelHandler(h SurfaceGetToplevelHandler) {
	if h != nil {
		p.mu.Lock()
		p.getToplevelHandlers = append(p.getToplevelHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveGetToplevelHandler(h SurfaceGetToplevelHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getToplevelHandlers {
		if e == h {
			p.getToplevelHandlers = append(p.getToplevelHandlers[:i], p.getToplevelHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceGetPopupEvent struct {
	Id         *Popup
	Parent     *Surface
	Positioner *Positioner
}

type SurfaceGetPopupHandler interface {
	HandleSurfaceGetPopup(SurfaceGetPopupEvent)
}

func (p *Surface) AddGetPopupHandler(h SurfaceGetPopupHandler) {
	if h != nil {
		p.mu.Lock()
		p.getPopupHandlers = append(p.getPopupHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveGetPopupHandler(h SurfaceGetPopupHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.getPopupHandlers {
		if e == h {
			p.getPopupHandlers = append(p.getPopupHandlers[:i], p.getPopupHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceSetWindowGeometryEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}

type SurfaceSetWindowGeometryHandler interface {
	HandleSurfaceSetWindowGeometry(SurfaceSetWindowGeometryEvent)
}

func (p *Surface) AddSetWindowGeometryHandler(h SurfaceSetWindowGeometryHandler) {
	if h != nil {
		p.mu.Lock()
		p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveSetWindowGeometryHandler(h SurfaceSetWindowGeometryHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setWindowGeometryHandlers {
		if e == h {
			p.setWindowGeometryHandlers = append(p.setWindowGeometryHandlers[:i], p.setWindowGeometryHandlers[i+1:]...)
			break
		}
	}
}

type SurfaceAckConfigureEvent struct {
	Serial uint32
}

type SurfaceAckConfigureHandler interface {
	HandleSurfaceAckConfigure(SurfaceAckConfigureEvent)
}

func (p *Surface) AddAckConfigureHandler(h SurfaceAckConfigureHandler) {
	if h != nil {
		p.mu.Lock()
		p.ackConfigureHandlers = append(p.ackConfigureHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Surface) RemoveAckConfigureHandler(h SurfaceAckConfigureHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.ackConfigureHandlers {
		if e == h {
			p.ackConfigureHandlers = append(p.ackConfigureHandlers[:i], p.ackConfigureHandlers[i+1:]...)
			break
		}
	}
}

func (p *Surface) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := SurfaceDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleSurfaceDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.getToplevelHandlers) > 0 {
			ev := SurfaceGetToplevelEvent{}
			ev.Id = NewToplevel(p.Context(), int(event.Uint32()))
			p.mu.RLock()
			for _, h := range p.getToplevelHandlers {
				h.HandleSurfaceGetToplevel(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.getPopupHandlers) > 0 {
			ev := SurfaceGetPopupEvent{}
			ev.Id = NewPopup(p.Context(), int(event.Uint32()))
			parent := event.Proxy(p.Context())
			if parent != nil {
				ev.Parent = parent.(*Surface)
			}
			ev.Positioner = event.Proxy(p.Context()).(*Positioner)
			p.mu.RLock()
			for _, h := range p.getPopupHandlers {
				h.HandleSurfaceGetPopup(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setWindowGeometryHandlers) > 0 {
			ev := SurfaceSetWindowGeometryEvent{}
			ev.X = event.Int32()
			ev.Y = event.Int32()
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setWindowGeometryHandlers {
				h.HandleSurfaceSetWindowGeometry(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.ackConfigureHandlers) > 0 {
			ev := SurfaceAckConfigureEvent{}
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.ackConfigureHandlers {
				h.HandleSurfaceAckConfigure(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Surface struct {
	wl.BaseProxy
	mu                        sync.RWMutex
	destroyHandlers           []SurfaceDestroyHandler
	getToplevelHandlers       []SurfaceGetToplevelHandler
	getPopupHandlers          []SurfaceGetPopupHandler
	setWindowGeometryHandlers []SurfaceSetWindowGeometryHandler
	ackConfigureHandlers      []SurfaceAckConfigureHandler
}

func NewSurface(ctx *wl.Context, id int) *Surface {
	ret := new(Surface)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will suggest a surface change.
//
//
// The configure event marks the end of a configure sequence. A configure
// sequence is a set of one or more events configuring the state of the
// xdg_surface, including the final xdg_surface.configure event.
//
// Where applicable, xdg_surface surface roles will during a configure
// sequence extend this event as a latched state sent as events before the
// xdg_surface.configure event. Such events should be considered to make up
// a set of atomically applied configuration states, where the
// xdg_surface.configure commits the accumulated state.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// If the client receives multiple configure events before it can respond
// to one, it is free to discard all but the last event it received.
//
func (p *Surface) Configure(serial uint32) error {
	return p.Context().SendRequest(p, 0, serial)
}

const (
	SurfaceErrorNotConstructed     = 1
	SurfaceErrorAlreadyConstructed = 2
	SurfaceErrorUnconfiguredBuffer = 3
)

type ToplevelDestroyEvent struct {
}

type ToplevelDestroyHandler interface {
	HandleToplevelDestroy(ToplevelDestroyEvent)
}

func (p *Toplevel) AddDestroyHandler(h ToplevelDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveDestroyHandler(h ToplevelDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetParentEvent struct {
	Parent *Toplevel
}

type ToplevelSetParentHandler interface {
	HandleToplevelSetParent(ToplevelSetParentEvent)
}

func (p *Toplevel) AddSetParentHandler(h ToplevelSetParentHandler) {
	if h != nil {
		p.mu.Lock()
		p.setParentHandlers = append(p.setParentHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetParentHandler(h ToplevelSetParentHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setParentHandlers {
		if e == h {
			p.setParentHandlers = append(p.setParentHandlers[:i], p.setParentHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetTitleEvent struct {
	Title string
}

type ToplevelSetTitleHandler interface {
	HandleToplevelSetTitle(ToplevelSetTitleEvent)
}

func (p *Toplevel) AddSetTitleHandler(h ToplevelSetTitleHandler) {
	if h != nil {
		p.mu.Lock()
		p.setTitleHandlers = append(p.setTitleHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetTitleHandler(h ToplevelSetTitleHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setTitleHandlers {
		if e == h {
			p.setTitleHandlers = append(p.setTitleHandlers[:i], p.setTitleHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetAppIdEvent struct {
	AppId string
}

type ToplevelSetAppIdHandler interface {
	HandleToplevelSetAppId(ToplevelSetAppIdEvent)
}

func (p *Toplevel) AddSetAppIdHandler(h ToplevelSetAppIdHandler) {
	if h != nil {
		p.mu.Lock()
		p.setAppIdHandlers = append(p.setAppIdHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetAppIdHandler(h ToplevelSetAppIdHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setAppIdHandlers {
		if e == h {
			p.setAppIdHandlers = append(p.setAppIdHandlers[:i], p.setAppIdHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelShowWindowMenuEvent struct {
	Seat   *wl.Seat
	Serial uint32
	X      int32
	Y      int32
}

type ToplevelShowWindowMenuHandler interface {
	HandleToplevelShowWindowMenu(ToplevelShowWindowMenuEvent)
}

func (p *Toplevel) AddShowWindowMenuHandler(h ToplevelShowWindowMenuHandler) {
	if h != nil {
		p.mu.Lock()
		p.showWindowMenuHandlers = append(p.showWindowMenuHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveShowWindowMenuHandler(h ToplevelShowWindowMenuHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.showWindowMenuHandlers {
		if e == h {
			p.showWindowMenuHandlers = append(p.showWindowMenuHandlers[:i], p.showWindowMenuHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelMoveEvent struct {
	Seat   *wl.Seat
	Serial uint32
}

type ToplevelMoveHandler interface {
	HandleToplevelMove(ToplevelMoveEvent)
}

func (p *Toplevel) AddMoveHandler(h ToplevelMoveHandler) {
	if h != nil {
		p.mu.Lock()
		p.moveHandlers = append(p.moveHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveMoveHandler(h ToplevelMoveHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.moveHandlers {
		if e == h {
			p.moveHandlers = append(p.moveHandlers[:i], p.moveHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelResizeEvent struct {
	Seat   *wl.Seat
	Serial uint32
	Edges  uint32
}

type ToplevelResizeHandler interface {
	HandleToplevelResize(ToplevelResizeEvent)
}

func (p *Toplevel) AddResizeHandler(h ToplevelResizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.resizeHandlers = append(p.resizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveResizeHandler(h ToplevelResizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.resizeHandlers {
		if e == h {
			p.resizeHandlers = append(p.resizeHandlers[:i], p.resizeHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetMaxSizeEvent struct {
	Width  int32
	Height int32
}

type ToplevelSetMaxSizeHandler interface {
	HandleToplevelSetMaxSize(ToplevelSetMaxSizeEvent)
}

func (p *Toplevel) AddSetMaxSizeHandler(h ToplevelSetMaxSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaxSizeHandlers = append(p.setMaxSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetMaxSizeHandler(h ToplevelSetMaxSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaxSizeHandlers {
		if e == h {
			p.setMaxSizeHandlers = append(p.setMaxSizeHandlers[:i], p.setMaxSizeHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetMinSizeEvent struct {
	Width  int32
	Height int32
}

type ToplevelSetMinSizeHandler interface {
	HandleToplevelSetMinSize(ToplevelSetMinSizeEvent)
}

func (p *Toplevel) AddSetMinSizeHandler(h ToplevelSetMinSizeHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMinSizeHandlers = append(p.setMinSizeHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetMinSizeHandler(h ToplevelSetMinSizeHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMinSizeHandlers {
		if e == h {
			p.setMinSizeHandlers = append(p.setMinSizeHandlers[:i], p.setMinSizeHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetMaximizedEvent struct {
}

type ToplevelSetMaximizedHandler interface {
	HandleToplevelSetMaximized(ToplevelSetMaximizedEvent)
}

func (p *Toplevel) AddSetMaximizedHandler(h ToplevelSetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMaximizedHandlers = append(p.setMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetMaximizedHandler(h ToplevelSetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMaximizedHandlers {
		if e == h {
			p.setMaximizedHandlers = append(p.setMaximizedHandlers[:i], p.setMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelUnsetMaximizedEvent struct {
}

type ToplevelUnsetMaximizedHandler interface {
	HandleToplevelUnsetMaximized(ToplevelUnsetMaximizedEvent)
}

func (p *Toplevel) AddUnsetMaximizedHandler(h ToplevelUnsetMaximizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveUnsetMaximizedHandler(h ToplevelUnsetMaximizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetMaximizedHandlers {
		if e == h {
			p.unsetMaximizedHandlers = append(p.unsetMaximizedHandlers[:i], p.unsetMaximizedHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetFullscreenEvent struct {
	Output *wl.Output
}

type ToplevelSetFullscreenHandler interface {
	HandleToplevelSetFullscreen(ToplevelSetFullscreenEvent)
}

func (p *Toplevel) AddSetFullscreenHandler(h ToplevelSetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.setFullscreenHandlers = append(p.setFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetFullscreenHandler(h ToplevelSetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setFullscreenHandlers {
		if e == h {
			p.setFullscreenHandlers = append(p.setFullscreenHandlers[:i], p.setFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelUnsetFullscreenEvent struct {
}

type ToplevelUnsetFullscreenHandler interface {
	HandleToplevelUnsetFullscreen(ToplevelUnsetFullscreenEvent)
}

func (p *Toplevel) AddUnsetFullscreenHandler(h ToplevelUnsetFullscreenHandler) {
	if h != nil {
		p.mu.Lock()
		p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveUnsetFullscreenHandler(h ToplevelUnsetFullscreenHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.unsetFullscreenHandlers {
		if e == h {
			p.unsetFullscreenHandlers = append(p.unsetFullscreenHandlers[:i], p.unsetFullscreenHandlers[i+1:]...)
			break
		}
	}
}

type ToplevelSetMinimizedEvent struct {
}

type ToplevelSetMinimizedHandler interface {
	HandleToplevelSetMinimized(ToplevelSetMinimizedEvent)
}

func (p *Toplevel) AddSetMinimizedHandler(h ToplevelSetMinimizedHandler) {
	if h != nil {
		p.mu.Lock()
		p.setMinimizedHandlers = append(p.setMinimizedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Toplevel) RemoveSetMinimizedHandler(h ToplevelSetMinimizedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.setMinimizedHandlers {
		if e == h {
			p.setMinimizedHandlers = append(p.setMinimizedHandlers[:i], p.setMinimizedHandlers[i+1:]...)
			break
		}
	}
}

func (p *Toplevel) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := ToplevelDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandleToplevelDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.setParentHandlers) > 0 {
			ev := ToplevelSetParentEvent{}
			parent := event.Proxy(p.Context())
			if parent != nil {
				ev.Parent = parent.(*Toplevel)
			}
			p.mu.RLock()
			for _, h := range p.setParentHandlers {
				h.HandleToplevelSetParent(ev)
			}
			p.mu.RUnlock()
		}
	case 2:
		if len(p.setTitleHandlers) > 0 {
			ev := ToplevelSetTitleEvent{}
			ev.Title = event.String()
			p.mu.RLock()
			for _, h := range p.setTitleHandlers {
				h.HandleToplevelSetTitle(ev)
			}
			p.mu.RUnlock()
		}
	case 3:
		if len(p.setAppIdHandlers) > 0 {
			ev := ToplevelSetAppIdEvent{}
			ev.AppId = event.String()
			p.mu.RLock()
			for _, h := range p.setAppIdHandlers {
				h.HandleToplevelSetAppId(ev)
			}
			p.mu.RUnlock()
		}
	case 4:
		if len(p.showWindowMenuHandlers) > 0 {
			ev := ToplevelShowWindowMenuEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.X = event.Int32()
			ev.Y = event.Int32()
			p.mu.RLock()
			for _, h := range p.showWindowMenuHandlers {
				h.HandleToplevelShowWindowMenu(ev)
			}
			p.mu.RUnlock()
		}
	case 5:
		if len(p.moveHandlers) > 0 {
			ev := ToplevelMoveEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.moveHandlers {
				h.HandleToplevelMove(ev)
			}
			p.mu.RUnlock()
		}
	case 6:
		if len(p.resizeHandlers) > 0 {
			ev := ToplevelResizeEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			ev.Edges = event.Uint32()
			p.mu.RLock()
			for _, h := range p.resizeHandlers {
				h.HandleToplevelResize(ev)
			}
			p.mu.RUnlock()
		}
	case 7:
		if len(p.setMaxSizeHandlers) > 0 {
			ev := ToplevelSetMaxSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setMaxSizeHandlers {
				h.HandleToplevelSetMaxSize(ev)
			}
			p.mu.RUnlock()
		}
	case 8:
		if len(p.setMinSizeHandlers) > 0 {
			ev := ToplevelSetMinSizeEvent{}
			ev.Width = event.Int32()
			ev.Height = event.Int32()
			p.mu.RLock()
			for _, h := range p.setMinSizeHandlers {
				h.HandleToplevelSetMinSize(ev)
			}
			p.mu.RUnlock()
		}
	case 9:
		if len(p.setMaximizedHandlers) > 0 {
			ev := ToplevelSetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMaximizedHandlers {
				h.HandleToplevelSetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 10:
		if len(p.unsetMaximizedHandlers) > 0 {
			ev := ToplevelUnsetMaximizedEvent{}
			p.mu.RLock()
			for _, h := range p.unsetMaximizedHandlers {
				h.HandleToplevelUnsetMaximized(ev)
			}
			p.mu.RUnlock()
		}
	case 11:
		if len(p.setFullscreenHandlers) > 0 {
			ev := ToplevelSetFullscreenEvent{}
			output := event.Proxy(p.Context())
			if output != nil {
				ev.Output = output.(*wl.Output)
			}
			p.mu.RLock()
			for _, h := range p.setFullscreenHandlers {
				h.HandleToplevelSetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 12:
		if len(p.unsetFullscreenHandlers) > 0 {
			ev := ToplevelUnsetFullscreenEvent{}
			p.mu.RLock()
			for _, h := range p.unsetFullscreenHandlers {
				h.HandleToplevelUnsetFullscreen(ev)
			}
			p.mu.RUnlock()
		}
	case 13:
		if len(p.setMinimizedHandlers) > 0 {
			ev := ToplevelSetMinimizedEvent{}
			p.mu.RLock()
			for _, h := range p.setMinimizedHandlers {
				h.HandleToplevelSetMinimized(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Toplevel struct {
	wl.BaseProxy
	mu                      sync.RWMutex
	destroyHandlers         []ToplevelDestroyHandler
	setParentHandlers       []ToplevelSetParentHandler
	setTitleHandlers        []ToplevelSetTitleHandler
	setAppIdHandlers        []ToplevelSetAppIdHandler
	showWindowMenuHandlers  []ToplevelShowWindowMenuHandler
	moveHandlers            []ToplevelMoveHandler
	resizeHandlers          []ToplevelResizeHandler
	setMaxSizeHandlers      []ToplevelSetMaxSizeHandler
	setMinSizeHandlers      []ToplevelSetMinSizeHandler
	setMaximizedHandlers    []ToplevelSetMaximizedHandler
	unsetMaximizedHandlers  []ToplevelUnsetMaximizedHandler
	setFullscreenHandlers   []ToplevelSetFullscreenHandler
	unsetFullscreenHandlers []ToplevelUnsetFullscreenHandler
	setMinimizedHandlers    []ToplevelSetMinimizedHandler
}

func NewToplevel(ctx *wl.Context, id int) *Toplevel {
	ret := new(Toplevel)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will suggest a surface change.
//
//
// This configure event asks the client to resize its toplevel surface or
// to change its state. The configured state should not be applied
// immediately. See xdg_surface.configure for details.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor needs to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients must send an ack_configure in response to this event. See
// xdg_surface.configure and xdg_surface.ack_configure for details.
//
func (p *Toplevel) Configure(width int32, height int32, states []int32) error {
	return p.Context().SendRequest(p, 0, width, height, states)
}

// Close will surface wants to be closed.
//
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any.
//
// This is only a request that the user intends to close the
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data, etc.
//
func (p *Toplevel) Close() error {
	return p.Context().SendRequest(p, 1)
}

const (
	ToplevelResizeEdgeNone        = 0
	ToplevelResizeEdgeTop         = 1
	ToplevelResizeEdgeBottom      = 2
	ToplevelResizeEdgeLeft        = 4
	ToplevelResizeEdgeTopLeft     = 5
	ToplevelResizeEdgeBottomLeft  = 6
	ToplevelResizeEdgeRight       = 8
	ToplevelResizeEdgeTopRight    = 9
	ToplevelResizeEdgeBottomRight = 10
)

const (
	ToplevelStateMaximized   = 1
	ToplevelStateFullscreen  = 2
	ToplevelStateResizing    = 3
	ToplevelStateActivated   = 4
	ToplevelStateTiledLeft   = 5
	ToplevelStateTiledRight  = 6
	ToplevelStateTiledTop    = 7
	ToplevelStateTiledBottom = 8
)

type PopupDestroyEvent struct {
}

type PopupDestroyHandler interface {
	HandlePopupDestroy(PopupDestroyEvent)
}

func (p *Popup) AddDestroyHandler(h PopupDestroyHandler) {
	if h != nil {
		p.mu.Lock()
		p.destroyHandlers = append(p.destroyHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Popup) RemoveDestroyHandler(h PopupDestroyHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.destroyHandlers {
		if e == h {
			p.destroyHandlers = append(p.destroyHandlers[:i], p.destroyHandlers[i+1:]...)
			break
		}
	}
}

type PopupGrabEvent struct {
	Seat   *wl.Seat
	Serial uint32
}

type PopupGrabHandler interface {
	HandlePopupGrab(PopupGrabEvent)
}

func (p *Popup) AddGrabHandler(h PopupGrabHandler) {
	if h != nil {
		p.mu.Lock()
		p.grabHandlers = append(p.grabHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Popup) RemoveGrabHandler(h PopupGrabHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.grabHandlers {
		if e == h {
			p.grabHandlers = append(p.grabHandlers[:i], p.grabHandlers[i+1:]...)
			break
		}
	}
}

func (p *Popup) Dispatch(event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.destroyHandlers) > 0 {
			ev := PopupDestroyEvent{}
			p.mu.RLock()
			for _, h := range p.destroyHandlers {
				h.HandlePopupDestroy(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.grabHandlers) > 0 {
			ev := PopupGrabEvent{}
			ev.Seat = event.Proxy(p.Context()).(*wl.Seat)
			ev.Serial = event.Uint32()
			p.mu.RLock()
			for _, h := range p.grabHandlers {
				h.HandlePopupGrab(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Popup struct {
	wl.BaseProxy
	mu              sync.RWMutex
	destroyHandlers []PopupDestroyHandler
	grabHandlers    []PopupGrabHandler
}

func NewPopup(ctx *wl.Context, id int) *Popup {
	ret := new(Popup)
	ctx.RegisterId(ret, id)
	return ret
}

// Configure will configure the popup surface.
//
//
// This event asks the popup surface to configure itself given the
// configuration. The configured state should not be applied immediately.
// See xdg_surface.configure for details.
//
// The x and y arguments represent the position the popup was placed at
// given the xdg_positioner rule, relative to the upper left corner of the
// window geometry of the parent surface.
//
func (p *Popup) Configure(x int32, y int32, width int32, height int32) error {
	return p.Context().SendRequest(p, 0, x, y, width, height)
}

// PopupDone will popup interaction is done.
//
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
//
func (p *Popup) PopupDone() error {
	return p.Context().SendRequest(p, 1)
}

const (
	PopupErrorInvalidGrab = 0
)
